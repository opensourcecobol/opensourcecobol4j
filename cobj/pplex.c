#line 2 "pplex.c"

#line 4 "pplex.c"

#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */

#define yy_create_buffer pp_create_buffer
#define yy_delete_buffer pp_delete_buffer
#define yy_scan_buffer pp_scan_buffer
#define yy_scan_string pp_scan_string
#define yy_scan_bytes pp_scan_bytes
#define yy_init_buffer pp_init_buffer
#define yy_flush_buffer pp_flush_buffer
#define yy_load_buffer_state pp_load_buffer_state
#define yy_switch_to_buffer pp_switch_to_buffer
#define yypush_buffer_state pppush_buffer_state
#define yypop_buffer_state pppop_buffer_state
#define yyensure_buffer_stack ppensure_buffer_stack
#define yy_flex_debug pp_flex_debug
#define yyin ppin
#define yyleng ppleng
#define yylex pplex
#define yylineno pplineno
#define yyout ppout
#define yyrestart pprestart
#define yytext pptext
#define yywrap ppwrap
#define yyalloc ppalloc
#define yyrealloc pprealloc
#define yyfree ppfree

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif

#ifdef yy_create_buffer
#define pp_create_buffer_ALREADY_DEFINED
#else
#define yy_create_buffer pp_create_buffer
#endif

#ifdef yy_delete_buffer
#define pp_delete_buffer_ALREADY_DEFINED
#else
#define yy_delete_buffer pp_delete_buffer
#endif

#ifdef yy_scan_buffer
#define pp_scan_buffer_ALREADY_DEFINED
#else
#define yy_scan_buffer pp_scan_buffer
#endif

#ifdef yy_scan_string
#define pp_scan_string_ALREADY_DEFINED
#else
#define yy_scan_string pp_scan_string
#endif

#ifdef yy_scan_bytes
#define pp_scan_bytes_ALREADY_DEFINED
#else
#define yy_scan_bytes pp_scan_bytes
#endif

#ifdef yy_init_buffer
#define pp_init_buffer_ALREADY_DEFINED
#else
#define yy_init_buffer pp_init_buffer
#endif

#ifdef yy_flush_buffer
#define pp_flush_buffer_ALREADY_DEFINED
#else
#define yy_flush_buffer pp_flush_buffer
#endif

#ifdef yy_load_buffer_state
#define pp_load_buffer_state_ALREADY_DEFINED
#else
#define yy_load_buffer_state pp_load_buffer_state
#endif

#ifdef yy_switch_to_buffer
#define pp_switch_to_buffer_ALREADY_DEFINED
#else
#define yy_switch_to_buffer pp_switch_to_buffer
#endif

#ifdef yypush_buffer_state
#define pppush_buffer_state_ALREADY_DEFINED
#else
#define yypush_buffer_state pppush_buffer_state
#endif

#ifdef yypop_buffer_state
#define pppop_buffer_state_ALREADY_DEFINED
#else
#define yypop_buffer_state pppop_buffer_state
#endif

#ifdef yyensure_buffer_stack
#define ppensure_buffer_stack_ALREADY_DEFINED
#else
#define yyensure_buffer_stack ppensure_buffer_stack
#endif

#ifdef yylex
#define pplex_ALREADY_DEFINED
#else
#define yylex pplex
#endif

#ifdef yyrestart
#define pprestart_ALREADY_DEFINED
#else
#define yyrestart pprestart
#endif

#ifdef yylex_init
#define pplex_init_ALREADY_DEFINED
#else
#define yylex_init pplex_init
#endif

#ifdef yylex_init_extra
#define pplex_init_extra_ALREADY_DEFINED
#else
#define yylex_init_extra pplex_init_extra
#endif

#ifdef yylex_destroy
#define pplex_destroy_ALREADY_DEFINED
#else
#define yylex_destroy pplex_destroy
#endif

#ifdef yyget_debug
#define ppget_debug_ALREADY_DEFINED
#else
#define yyget_debug ppget_debug
#endif

#ifdef yyset_debug
#define ppset_debug_ALREADY_DEFINED
#else
#define yyset_debug ppset_debug
#endif

#ifdef yyget_extra
#define ppget_extra_ALREADY_DEFINED
#else
#define yyget_extra ppget_extra
#endif

#ifdef yyset_extra
#define ppset_extra_ALREADY_DEFINED
#else
#define yyset_extra ppset_extra
#endif

#ifdef yyget_in
#define ppget_in_ALREADY_DEFINED
#else
#define yyget_in ppget_in
#endif

#ifdef yyset_in
#define ppset_in_ALREADY_DEFINED
#else
#define yyset_in ppset_in
#endif

#ifdef yyget_out
#define ppget_out_ALREADY_DEFINED
#else
#define yyget_out ppget_out
#endif

#ifdef yyset_out
#define ppset_out_ALREADY_DEFINED
#else
#define yyset_out ppset_out
#endif

#ifdef yyget_leng
#define ppget_leng_ALREADY_DEFINED
#else
#define yyget_leng ppget_leng
#endif

#ifdef yyget_text
#define ppget_text_ALREADY_DEFINED
#else
#define yyget_text ppget_text
#endif

#ifdef yyget_lineno
#define ppget_lineno_ALREADY_DEFINED
#else
#define yyget_lineno ppget_lineno
#endif

#ifdef yyset_lineno
#define ppset_lineno_ALREADY_DEFINED
#else
#define yyset_lineno ppset_lineno
#endif

#ifdef yywrap
#define ppwrap_ALREADY_DEFINED
#else
#define yywrap ppwrap
#endif

#ifdef yyalloc
#define ppalloc_ALREADY_DEFINED
#else
#define yyalloc ppalloc
#endif

#ifdef yyrealloc
#define pprealloc_ALREADY_DEFINED
#else
#define yyrealloc pprealloc
#endif

#ifdef yyfree
#define ppfree_ALREADY_DEFINED
#else
#define yyfree ppfree
#endif

#ifdef yytext
#define pptext_ALREADY_DEFINED
#else
#define yytext pptext
#endif

#ifdef yyleng
#define ppleng_ALREADY_DEFINED
#else
#define yyleng ppleng
#endif

#ifdef yyin
#define ppin_ALREADY_DEFINED
#else
#define yyin ppin
#endif

#ifdef yyout
#define ppout_ALREADY_DEFINED
#else
#define yyout ppout
#endif

#ifdef yy_flex_debug
#define pp_flex_debug_ALREADY_DEFINED
#else
#define yy_flex_debug pp_flex_debug
#endif

#ifdef yylineno
#define pplineno_ALREADY_DEFINED
#else
#define yylineno pplineno
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* begin standard C++ headers. */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif

/* The state buf must be large enough to hold one state per character in the
 * main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))

#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

#define YY_LESS_LINENO(n)
#define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                              \
  do {                                                                         \
    /* Undo effects of setting up yytext. */                                   \
    int yyless_macro_arg = (n);                                                \
    YY_LESS_LINENO(yyless_macro_arg);                                          \
    *yy_cp = (yy_hold_char);                                                   \
    YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp =                            \
        yy_bp + yyless_macro_arg - YY_MORE_ADJ;                                \
    YY_DO_BEFORE_ACTION; /* set up yytext again */                             \
  } while (0)
#define unput(c) yyunput(c, (yytext_ptr))

#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state {
  FILE *yy_input_file;

  char *yy_ch_buf;  /* input buffer */
  char *yy_buf_pos; /* current position in input buffer */

  /* Size of input buffer in bytes, not including room for EOB
   * characters.
   */
  int yy_buf_size;

  /* Number of characters read into yy_ch_buf, not including EOB
   * characters.
   */
  int yy_n_chars;

  /* Whether we "own" the buffer - i.e., we know we created it,
   * and can realloc() it to grow it, and should free() it to
   * delete it.
   */
  int yy_is_our_buffer;

  /* Whether this is an "interactive" input source; if so, and
   * if we're using stdio for input, then we want to use getc()
   * instead of fread(), to make sure we stop fetching input after
   * each newline.
   */
  int yy_is_interactive;

  /* Whether we're considered to be at the beginning of a line.
   * If so, '^' rules will be active on the next match, otherwise
   * not.
   */
  int yy_at_bol;

  int yy_bs_lineno; /**< The line count. */
  int yy_bs_column; /**< The column count. */

  /* Whether to try to fill the input buffer when we reach the
   * end of it.
   */
  int yy_fill_buffer;

  int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
  /* When an EOF's been seen but there's still some text to process
   * then we mark the buffer as YY_EOF_PENDING, to indicate that we
   * shouldn't try reading from the input source any more.  We might
   * still have a bunch of tokens to match, though, because of
   * possible backing-up.
   *
   * When we actually see the EOF, we change the status to "new"
   * (via yyrestart()), so that the user can continue scanning by
   * just pointing yyin at a new input file.
   */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE *yy_buffer_stack = NULL; /**< Stack as an array. */

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER                                                      \
  ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]

/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart(FILE *input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);

static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)

YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char *yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char *bytes, int len);

void *yyalloc(yy_size_t);
void *yyrealloc(void *, yy_size_t);
void yyfree(void *);

#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                     \
  {                                                                            \
    if (!YY_CURRENT_BUFFER) {                                                  \
      yyensure_buffer_stack();                                                 \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);          \
    }                                                                          \
    YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;              \
  }
#define yy_set_bol(at_bol)                                                     \
  {                                                                            \
    if (!YY_CURRENT_BUFFER) {                                                  \
      yyensure_buffer_stack();                                                 \
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);          \
    }                                                                          \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                              \
  }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)

/* Begin user sect3 */

#define ppwrap() (/*CONSTCOND*/ 1)
#define YY_SKIP_YYWRAP
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char *yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char *msg);

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                    \
  (yytext_ptr) = yy_bp;                                                        \
  yyleng = (int)(yy_cp - yy_bp);                                               \
  (yy_hold_char) = *yy_cp;                                                     \
  *yy_cp = '\0';                                                               \
  (yy_c_buf_p) = yy_cp;
#define YY_NUM_RULES 99
#define YY_END_OF_BUFFER 100
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info {
  flex_int32_t yy_verify;
  flex_int32_t yy_nxt;
};
static const flex_int16_t yy_accept[609] = {
    0,  0,  0,  16, 16, 0,  0,  0,  0,  0,  0,  100, 98, 73, 74, 98, 98,
    76, 77, 98, 98, 98, 95, 94, 95, 98, 95, 95, 95,  95, 95, 95, 95, 95,
    95, 95, 95, 95, 98, 98, 74, 12, 13, 93, 98, 16,  15, 16, 12, 13, 44,
    20, 21, 44, 44, 24, 25, 44, 44, 44, 41, 22, 41,  44, 44, 41, 41, 41,
    41, 41, 41, 41, 41, 41, 41, 41, 44, 44, 12, 13,  51, 45, 46, 51, 51,
    51, 51, 51, 48, 51, 48, 51, 51, 48, 51, 51, 12,  13, 60, 55, 56,

    60, 60, 60, 60, 60, 57, 60, 57, 60, 57, 57, 57,  57, 60, 60, 12, 13,
    74, 0,  0,  97, 0,  1,  0,  96, 73, 75, 0,  95,  95, 0,  0,  74, 0,
    95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95,  95, 95, 95, 95, 95,
    95, 95, 95, 95, 95, 74, 93, 0,  12, 1,  13, 93,  16, 1,  12, 1,  13,
    21, 0,  0,  43, 0,  0,  42, 20, 41, 41, 0,  0,   23, 36, 26, 27, 41,
    41, 28, 41, 41, 41, 41, 46, 0,  0,  50, 0,  0,   49, 45, 48,

    48, 0,  0,  47, 56, 0,  0,  59, 0,  0,  58, 55,  57, 57, 0,  0,  57,
    57, 57, 1,  95, 95, 0,  0,  95, 95, 95, 95, 95,  95, 95, 95, 95, 95,
    0,  95, 0,  95, 95, 0,  0,  95, 95, 95, 95, 95,  95, 95, 95, 0,  0,
    95, 1,  1,  1,  41, 41, 29, 41, 41, 41, 41, 41,  41, 57, 57, 57, 0,
    0,  0,  0,  89, 0,  95, 95, 17, 95, 95, 95, 0,   0,  95, 95, 95, 95,
    0,  0,  95, 95, 95, 80, 0,  95, 95, 95, 95, 95,  95, 95, 95,

    95, 95, 92, 0,  95, 41, 41, 41, 41, 41, 41, 41,  41, 52, 57, 57, 82,
    0,  81, 0,  95, 95, 0,  0,  95, 69, 0,  0,  0,   95, 95, 0,  0,  95,
    0,  95, 95, 95, 0,  0,  95, 95, 95, 95, 95, 95,  70, 71, 72, 95, 0,
    0,  95, 41, 41, 41, 41, 41, 41, 41, 41, 57, 57,  62, 95, 0,  0,  95,
    95, 95, 69, 0,  0,  95, 0,  0,  91, 0,  95, 0,   95, 95, 95, 90, 0,
    95, 95, 95, 95, 95, 95, 95, 70, 71, 72, 95, 84,  0,  0,  95,

    0,  41, 41, 37, 41, 41, 38, 41, 41, 57, 57, 95,  0,  95, 95, 95, 0,
    0,  95, 85, 0,  95, 0,  95, 18, 95, 95, 14, 95,  95, 67, 19, 95, 95,
    78, 0,  0,  0,  35, 33, 41, 41, 41, 41, 41, 41,  53, 54, 95, 0,  95,
    95, 95, 0,  0,  95, 95, 0,  95, 95, 95, 95, 95,  68, 0,  0,  79, 0,
    41, 31, 41, 41, 30, 34, 0,  0,  0,  95, 95, 95,  0,  0,  95, 0,  95,
    0,  0,  95, 95, 95, 95, 61, 83, 0,  39, 32, 40,  86, 0,  0,

    0,  0,  95, 95, 95, 0,  0,  95, 0,  0,  95, 0,   95, 95, 0,  0,  5,
    0,  0,  0,  95, 95, 95, 0,  10, 95, 0,  6,  0,   95, 95, 0,  0,  0,
    0,  0,  0,  95, 95, 63, 11, 0,  0,  0,  0,  3,   0,  95, 66, 0,  0,
    0,  8,  65, 64, 0,  0,  0,  95, 0,  0,  0,  0,   0,  95, 0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,  87, 0,  0,  0,
    0,  0,  0,  0,  0,  4,  0,  0,  9,  0,  0,  0,   0,  88, 7,

    0,  0,  0,  0,  0,  2,  0,  0};

static const YY_CHAR yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  3,  1,  4,  1,  1,  1,
    1,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15, 16, 17, 14, 14, 14, 14, 14,
    14, 1,  18, 1,  19, 20, 1,  21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 38, 47, 47, 47, 47,
    38, 47, 48, 49, 50, 51,

    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 38, 64, 65, 66, 67, 68, 69,
    70, 71, 38, 47, 47, 47, 47, 1,  47, 72, 73, 73, 73, 73, 73, 73, 73, 73, 73,
    73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
    73, 73, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
    74, 74, 74, 74, 74,

    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
    74, 74, 74, 74, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73,
    73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 1,  1,  1};

static const YY_CHAR yy_meta[75] = {
    0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 3, 3, 3, 1, 3, 3, 3, 3, 1, 1, 1, 1, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3};

static const flex_int16_t yy_base[632] = {
    0,    0,    72,   74,   82,   144,  70,   218,  291,  364,  83,   871,
    3699, 3699, 241,  866,  858,  3699, 3699, 839,  87,   243,  252,  95,
    260,  245,  429,  67,   436,  432,  446,  473,  501,  517,  512,  539,
    532,  545,  609,  617,  268,  831,  0,    586,  625,  0,    3699, 829,
    808,  0,    3699, 3699, 246,  808,  787,  3699, 3699, 771,  103,  651,
    633,  111,  659,  248,  755,  276,  487,  645,  667,  671,  674,  677,
    681,  684,  699,  703,  748,  767,  753,  0,    3699, 3699, 249,  764,
    747,  717,  119,  784,  792,  340,  801,  448,  715,  717,  810,  822,
    699,  0,    3699, 3699, 251,

    710,  698,  679,  449,  838,  865,  873,  881,  471,  832,  850,  889,
    899,  918,  931,  677,  0,    258,  671,  676,  3699, 646,  0,    903,
    965,  3699, 270,  601,  835,  973,  981,  989,  275,  589,  997,  1001,
    1012, 1006, 1025, 1009, 1028, 1051, 1031, 1055, 1077, 1096, 1101, 1127,
    1104, 1108, 1150, 1083, 1122, 1133, 1155, 1130, 475,  226,  571,  0,
    0,    0,    1176, 0,    0,    0,    0,    0,    286,  565,  579,  3699,
    577,  1202, 1219, 3699, 1173, 1227, 1240, 1248, 3699, 1199, 1220, 1256,
    1264, 1267, 1270, 1278, 1295, 1334, 1300, 442,  554,  568,  3699, 565,
    1364, 1374, 3699, 1291,

    1384, 1398, 1406, 3699, 444,  513,  527,  3699, 512,  1414, 1422, 3699,
    1392, 1432, 1456, 1464, 1423, 1477, 1451, 0,    1480, 1496, 953,  1518,
    1490, 1506, 1510, 1532, 1549, 1440, 1545, 1554, 1564, 1578, 481,  1581,
    1645, 1575, 1597, 1629, 1661, 1655, 1669, 1673, 1676, 1679, 1690, 1693,
    1697, 1758, 1766, 1725, 0,    0,    0,    1774, 1743, 1778, 1781, 1791,
    1800, 1795, 1807, 1813, 1819, 1828, 1845, 1879, 1895, 1911, 1919, 312,
    466,  1887, 1909, 1865, 1912, 1933, 1929, 698,  1957, 1951, 1936, 1977,
    1945, 68,   455,  1981, 1984, 1988, 320,  449,  2017, 2020, 2002, 2025,
    2030, 2033, 2052, 2067,

    2075, 2097, 329,  446,  2100, 2058, 2103, 2108, 2055, 2131, 2144, 2122,
    2125, 2134, 2173, 2177, 345,  434,  563,  431,  2180, 2199, 961,  2212,
    2224, 2208, 39,   77,   422,  2227, 2252, 2288, 2296, 2265, 213,  2306,
    2276, 2282, 2317, 2353, 2332, 2318, 2346, 2341, 2335, 2365, 2370, 2374,
    2382, 2399, 2414, 2446, 2438, 2424, 2454, 2463, 2458, 2467, 2471, 2480,
    2489, 2495, 2513, 2492, 2537, 419,  419,  2544, 2559, 2563, 3699, 418,
    424,  2547, 2574, 2627, 592,  332,  2587, 498,  2603, 2614, 2595, 599,
    330,  2591, 2640, 2635, 2643, 2660, 2667, 2679, 3699, 3699, 3699, 2682,
    943,  310,  2707, 2724,

    2746, 2718, 2731, 2738, 2754, 2765, 2768, 2774, 2771, 2761, 2790, 2795,
    271,  2818, 2841, 2844, 545,  616,  2838, 1269, 301,  2810, 417,  2847,
    2807, 2874, 2863, 2877, 2883, 2889, 2894, 2897, 2911, 2922, 1302, 298,
    2928, 2964, 2916, 2941, 2961, 2981, 2989, 2994, 2998, 3011, 2953, 3005,
    3034, 622,  3031, 3018, 3039, 459,  471,  3046, 3076, 632,  3085, 3089,
    3098, 3103, 3113, 3110, 3124, 3177, 3129, 266,  3153, 3142, 3156, 3162,
    3167, 3185, 3216, 3238, 483,  3211, 3190, 3235, 652,  668,  3226, 1459,
    3256, 3279, 659,  3270, 3267, 3201, 3294, 3259, 1310, 259,  3299, 3303,
    3310, 1338, 665,  523,

    258,  682,  3315, 3323, 3326, 686,  759,  3339, 767,  242,  3334, 768,
    3348, 3374, 1466, 3412, 3344, 799,  864,  810,  3382, 3392, 3358, 823,
    3699, 3429, 617,  3403, 527,  3433, 3425, 838,  122,  853,  1107, 121,
    865,  3441, 3457, 3438, 3699, 1671, 3505, 884,  1005, 3699, 117,  3471,
    3462, 712,  954,  961,  3699, 3467, 3475, 993,  116,  745,  3515, 996,
    996,  995,  762,  1002, 3481, 838,  1311, 1019, 1036, 1069, 1786, 3545,
    1091, 3565, 111,  1160, 866,  1163, 1191, 109,  1234, 1596, 1276, 1291,
    1353, 906,  1296, 1523, 1297, 1548, 3699, 101,  1319, 3699, 3569, 93,
    1331, 994,  1699, 3699,

    1339, 1341, 1350, 1646, 1728, 3699, 87,   3699, 3641, 3644, 3647, 3650,
    97,   3653, 3656, 3659, 3662, 3665, 3668, 3671, 91,   3674, 3677, 90,
    3680, 3683, 89,   3686, 3689, 3692, 3695};

static const flex_int16_t yy_def[632] = {
    0,   608, 1,   609, 609, 608, 5,   610, 610, 608, 9,   608, 608, 608, 608,
    611, 612, 608, 608, 608, 608, 608, 613, 608, 613, 608, 613, 613, 613, 613,
    613, 613, 613, 613, 613, 613, 613, 613, 613, 613, 608, 614, 615, 613, 613,
    616, 608, 616, 617, 618, 608, 608, 608, 619, 620, 608, 608, 608, 608, 608,
    621, 608, 621, 608, 608, 621, 621, 621, 621, 621, 621, 621, 621, 621, 621,
    621, 621, 621, 614, 615, 608, 608, 608, 622, 623, 608, 608, 608, 624, 608,
    624, 608, 608, 624, 624, 624, 614, 615, 608, 608, 608,

    625, 626, 608, 608, 608, 627, 608, 627, 608, 627, 627, 627, 627, 627, 627,
    614, 615, 608, 608, 611, 608, 612, 628, 608, 608, 608, 608, 608, 613, 613,
    613, 613, 608, 608, 613, 613, 613, 613, 613, 613, 613, 613, 613, 613, 613,
    613, 613, 613, 613, 613, 613, 613, 613, 613, 613, 613, 608, 608, 608, 614,
    629, 615, 613, 616, 630, 617, 631, 618, 608, 608, 619, 608, 620, 608, 608,
    608, 621, 621, 621, 621, 608, 621, 621, 621, 621, 621, 621, 621, 621, 621,
    621, 608, 608, 622, 608, 623, 608, 608, 608, 624,

    624, 624, 624, 608, 608, 608, 625, 608, 626, 608, 608, 608, 627, 627, 627,
    627, 627, 627, 627, 628, 613, 613, 608, 613, 613, 613, 613, 613, 613, 613,
    613, 613, 613, 613, 608, 613, 613, 613, 613, 608, 613, 613, 613, 613, 613,
    613, 613, 613, 613, 608, 613, 613, 629, 630, 631, 621, 621, 621, 621, 621,
    621, 621, 621, 621, 627, 627, 627, 608, 613, 608, 613, 608, 608, 613, 613,
    613, 613, 613, 613, 608, 613, 613, 613, 613, 613, 608, 608, 613, 613, 613,
    608, 608, 613, 613, 613, 613, 613, 613, 613, 613,

    613, 613, 608, 608, 613, 621, 621, 621, 621, 621, 621, 621, 621, 627, 627,
    627, 608, 608, 608, 608, 613, 613, 608, 613, 613, 613, 608, 608, 608, 613,
    613, 608, 613, 613, 608, 613, 613, 613, 608, 613, 613, 613, 613, 613, 613,
    613, 613, 613, 613, 613, 608, 613, 613, 621, 621, 621, 621, 621, 621, 621,
    621, 627, 627, 613, 613, 608, 608, 613, 613, 613, 608, 608, 608, 613, 608,
    613, 608, 608, 613, 608, 613, 613, 613, 608, 608, 613, 613, 613, 613, 613,
    613, 613, 608, 608, 608, 613, 608, 608, 608, 613,

    613, 621, 621, 621, 621, 621, 621, 621, 621, 627, 627, 613, 608, 613, 613,
    613, 608, 608, 613, 608, 608, 613, 608, 613, 613, 613, 613, 613, 613, 613,
    613, 613, 613, 613, 608, 608, 608, 613, 621, 621, 621, 621, 621, 621, 621,
    621, 627, 627, 613, 608, 613, 613, 613, 608, 608, 613, 613, 608, 613, 613,
    613, 613, 613, 613, 608, 613, 608, 608, 621, 621, 621, 621, 621, 621, 608,
    613, 608, 613, 613, 613, 608, 608, 613, 608, 613, 613, 608, 613, 613, 613,
    613, 613, 608, 608, 621, 621, 621, 608, 608, 608,

    608, 608, 613, 613, 613, 608, 608, 613, 608, 608, 613, 608, 613, 613, 608,
    613, 613, 608, 608, 608, 613, 613, 613, 608, 608, 613, 608, 613, 608, 613,
    613, 608, 608, 608, 608, 608, 608, 613, 613, 613, 608, 608, 613, 608, 608,
    608, 608, 613, 613, 608, 608, 608, 608, 613, 613, 608, 608, 608, 613, 608,
    608, 608, 608, 608, 613, 608, 608, 608, 608, 608, 608, 613, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608,

    608, 608, 608, 608, 608, 608, 608, 0,   608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608};

static const flex_int16_t yy_nxt[3774] = {
    0,   12,  13,  14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  12,  24,
    24,  24,  24,  25,  12,  12,  12,  26,  27,  28,  29,  30,  31,  27,  27,
    32,  27,  27,  27,  27,  27,  27,  33,  27,  34,  35,  36,  27,  37,  27,
    27,  27,  12,  26,  27,  28,  29,  30,  31,  27,  27,  32,  27,  27,  27,
    27,  27,  27,  33,  34,  35,  36,  27,  37,  27,  27,  27,  38,  39,  27,
    40,  46,  608, 78,  608, 41,  372, 47,  79,  46,  42,  43,  43,  43,  43,
    48,  116, 213, 200, 177, 49,  117, 124, 335, 124, 129,

    125, 125, 125, 125, 124, 372, 124, 605, 125, 125, 125, 125, 174, 595, 174,
    373, 175, 175, 175, 175, 174, 590, 174, 335, 175, 175, 175, 175, 197, 571,
    197, 574, 198, 198, 198, 198, 542, 545, 131, 132, 373, 535, 515, 44,  50,
    51,  52,  53,  54,  55,  56,  57,  58,  59,  60,  61,  50,  62,  62,  62,
    62,  63,  64,  50,  50,  65,  66,  67,  67,  67,  67,  67,  67,  68,  69,
    67,  70,  67,  67,  71,  72,  67,  73,  74,  75,  67,  67,  67,  67,  67,
    50,  65,  66,  67,  67,  67,  67,  67,  67,  68,

    69,  67,  70,  67,  67,  71,  72,  73,  74,  75,  67,  67,  67,  67,  67,
    76,  77,  67,  80,  81,  82,  83,  84,  80,  80,  85,  86,  87,  88,  89,
    80,  90,  90,  90,  90,  91,  92,  80,  80,  158, 158, 158, 158, 118, 126,
    127, 126, 133, 169, 176, 169, 192, 124, 205, 124, 380, 125, 125, 125, 125,
    118, 124, 484, 124, 80,  130, 130, 130, 130, 124, 157, 124, 127, 130, 130,
    130, 130, 133, 475, 465, 380, 158, 158, 158, 158, 608, 437, 608, 169, 94,
    95,  80,  81,  82,  83,  84,  80,  80,  96,  86,

    87,  88,  89,  97,  90,  90,  90,  90,  91,  92,  80,  80,  119, 450, 128,
    182, 134, 170, 399, 170, 193, 375, 206, 131, 132, 272, 272, 272, 272, 119,
    351, 131, 132, 291, 291, 291, 291, 80,  450, 159, 182, 128, 303, 303, 303,
    303, 134, 179, 180, 197, 339, 197, 332, 198, 198, 198, 198, 170, 317, 317,
    317, 317, 94,  95,  98,  99,  100, 101, 102, 98,  98,  103, 104, 105, 106,
    107, 98,  108, 108, 108, 108, 109, 98,  98,  98,  110, 110, 111, 110, 110,
    110, 110, 110, 112, 110, 110, 110, 110, 110, 110,

    110, 110, 113, 110, 110, 110, 110, 110, 110, 110, 98,  110, 110, 111, 110,
    110, 110, 110, 110, 112, 110, 110, 110, 110, 110, 110, 110, 113, 110, 110,
    110, 110, 110, 110, 110, 114, 115, 110, 608, 323, 608, 608, 280, 608, 192,
    608, 205, 608, 413, 199, 192, 270, 417, 140, 268, 608, 458, 608, 210, 418,
    210, 135, 211, 211, 211, 211, 250, 136, 137, 240, 138, 139, 212, 205, 413,
    235, 141, 157, 417, 140, 142, 458, 608, 235, 608, 418, 223, 135, 158, 158,
    158, 158, 136, 137, 143, 138, 608, 139, 608, 481,

    131, 132, 141, 131, 132, 286, 142, 131, 132, 482, 608, 144, 608, 193, 145,
    206, 208, 131, 132, 193, 143, 608, 502, 608, 481, 146, 608, 423, 608, 545,
    208, 286, 183, 205, 482, 147, 144, 151, 546, 145, 148, 608, 206, 608, 131,
    132, 159, 502, 608, 149, 608, 146, 287, 423, 608, 150, 608, 183, 179, 180,
    154, 147, 519, 151, 152, 148, 156, 155, 454, 195, 153, 195, 131, 132, 192,
    149, 319, 319, 319, 319, 150, 172, 172, 131, 132, 169, 154, 519, 131, 132,
    152, 157, 156, 155, 454, 124, 153, 124, 547, 163,

    163, 163, 163, 131, 132, 377, 377, 377, 377, 133, 131, 132, 384, 384, 384,
    384, 131, 132, 608, 608, 608, 127, 608, 608, 608, 608, 608, 608, 608, 118,
    608, 608, 608, 608, 608, 608, 608, 129, 608, 608, 608, 608, 174, 455, 174,
    157, 178, 178, 178, 178, 121, 477, 176, 169, 608, 129, 608, 131, 132, 544,
    174, 487, 174, 129, 175, 175, 175, 175, 174, 455, 174, 129, 178, 178, 178,
    178, 608, 477, 608, 121, 608, 506, 608, 608, 544, 608, 608, 487, 608, 507,
    608, 118, 608, 608, 512, 608, 161, 518, 123, 186,

    280, 184, 208, 187, 179, 180, 185, 506, 608, 189, 608, 520, 608, 208, 608,
    507, 179, 180, 161, 188, 512, 524, 170, 518, 327, 186, 608, 184, 608, 187,
    179, 180, 185, 204, 328, 189, 123, 520, 179, 180, 190, 191, 179, 180, 188,
    179, 180, 524, 179, 180, 327, 195, 179, 180, 560, 179, 180, 608, 608, 608,
    328, 608, 608, 608, 608, 190, 191, 195, 169, 329, 179, 180, 161, 181, 179,
    180, 608, 608, 608, 560, 608, 608, 608, 608, 564, 199, 192, 177, 202, 203,
    123, 172, 525, 197, 177, 197, 527, 198, 198, 198,

    198, 197, 529, 197, 569, 201, 201, 201, 201, 564, 197, 172, 197, 177, 201,
    201, 201, 201, 525, 608, 608, 608, 527, 608, 608, 608, 608, 167, 529, 569,
    192, 608, 608, 608, 534, 608, 608, 608, 608, 212, 205, 608, 200, 608, 608,
    537, 608, 210, 165, 210, 161, 211, 211, 211, 211, 193, 200, 541, 123, 608,
    534, 608, 121, 202, 203, 535, 535, 550, 200, 121, 608, 537, 202, 203, 210,
    551, 210, 573, 214, 214, 214, 214, 210, 541, 210, 217, 211, 211, 211, 211,
    210, 608, 210, 550, 214, 214, 214, 214, 608, 553,

    608, 551, 573, 215, 216, 584, 131, 132, 608, 206, 608, 217, 124, 558, 124,
    608, 125, 125, 125, 125, 608, 215, 216, 218, 219, 553, 608, 608, 608, 608,
    584, 608, 608, 608, 608, 536, 215, 216, 205, 558, 608, 608, 608, 608, 608,
    608, 608, 608, 593, 218, 219, 213, 215, 216, 223, 223, 397, 397, 397, 397,
    215, 216, 608, 323, 213, 608, 272, 272, 272, 272, 215, 216, 608, 593, 124,
    561, 124, 213, 125, 125, 125, 125, 124, 608, 124, 366, 130, 130, 130, 130,
    608, 608, 608, 562, 608, 608, 608, 608, 608, 608,

    608, 561, 608, 608, 608, 608, 608, 545, 608, 129, 608, 366, 608, 223, 223,
    608, 546, 608, 608, 562, 608, 608, 563, 608, 273, 566, 222, 129, 567, 221,
    568, 570, 367, 601, 608, 129, 608, 608, 608, 608, 608, 576, 608, 608, 131,
    132, 225, 608, 563, 228, 608, 566, 222, 229, 567, 221, 568, 570, 601, 226,
    608, 227, 608, 232, 608, 577, 608, 576, 131, 132, 608, 225, 131, 132, 228,
    230, 547, 131, 132, 229, 131, 132, 608, 224, 132, 226, 608, 227, 608, 232,
    233, 577, 608, 231, 608, 608, 131, 132, 235, 131,

    132, 230, 131, 132, 578, 608, 247, 608, 535, 535, 608, 234, 608, 608, 608,
    608, 233, 608, 231, 608, 581, 236, 131, 132, 238, 608, 131, 132, 240, 240,
    578, 608, 247, 608, 552, 608, 608, 234, 608, 608, 239, 608, 608, 243, 608,
    242, 581, 236, 131, 132, 238, 248, 608, 608, 131, 132, 250, 250, 608, 608,
    552, 608, 252, 608, 608, 239, 608, 237, 132, 243, 242, 249, 131, 132, 244,
    131, 132, 248, 536, 131, 132, 583, 608, 245, 608, 124, 246, 124, 252, 163,
    163, 163, 163, 131, 132, 608, 249, 585, 241, 132,

    244, 131, 132, 608, 131, 132, 608, 583, 608, 245, 608, 174, 246, 174, 608,
    175, 175, 175, 175, 608, 586, 131, 132, 585, 608, 608, 251, 132, 174, 608,
    174, 608, 175, 175, 175, 175, 174, 608, 174, 608, 178, 178, 178, 178, 179,
    180, 586, 131, 132, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 177, 587, 179, 180, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 420, 420, 420, 420, 177, 608, 257, 608,
    608, 179, 180, 256, 177, 587, 258, 608, 179, 180,

    608, 608, 608, 259, 608, 608, 608, 260, 588, 608, 608, 608, 574, 574, 257,
    435, 435, 435, 435, 256, 589, 264, 258, 493, 493, 493, 493, 179, 180, 259,
    594, 261, 597, 260, 588, 179, 180, 608, 179, 180, 608, 179, 180, 608, 608,
    608, 589, 264, 598, 179, 180, 498, 498, 498, 498, 590, 594, 261, 597, 608,
    262, 608, 202, 203, 591, 600, 179, 180, 602, 608, 263, 179, 180, 197, 598,
    197, 603, 198, 198, 198, 198, 608, 575, 197, 604, 197, 262, 198, 198, 198,
    198, 600, 608, 197, 602, 197, 263, 201, 201, 201,

    201, 608, 603, 608, 608, 179, 180, 608, 608, 608, 604, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 210, 592, 210, 200, 211, 211, 211,
    211, 210, 608, 210, 608, 211, 211, 211, 211, 608, 608, 210, 280, 210, 200,
    214, 214, 214, 214, 608, 608, 608, 200, 608, 608, 202, 203, 608, 608, 265,
    608, 484, 608, 215, 216, 608, 608, 608, 515, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 268, 268, 509, 213, 265, 608, 267, 608, 608,
    532, 608, 608, 608, 215, 216, 608, 270, 270, 608,

    266, 608, 213, 215, 216, 608, 608, 608, 608, 509, 213, 281, 132, 267, 608,
    608, 532, 608, 274, 608, 608, 608, 215, 216, 595, 595, 266, 608, 608, 608,
    510, 608, 608, 608, 608, 608, 608, 533, 223, 608, 608, 608, 608, 608, 274,
    275, 608, 608, 215, 216, 590, 269, 132, 277, 608, 276, 608, 278, 608, 591,
    608, 131, 132, 608, 129, 608, 608, 271, 132, 608, 275, 608, 279, 608, 282,
    608, 608, 131, 132, 277, 276, 131, 132, 278, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 283, 596, 608, 608, 284, 279, 608,

    282, 285, 608, 131, 132, 608, 608, 289, 608, 582, 582, 582, 582, 608, 608,
    288, 131, 132, 283, 592, 131, 132, 608, 284, 608, 131, 132, 285, 608, 608,
    240, 240, 608, 289, 608, 131, 132, 290, 608, 608, 608, 288, 291, 291, 291,
    291, 131, 132, 605, 131, 132, 608, 131, 132, 608, 608, 608, 606, 608, 608,
    608, 608, 290, 608, 608, 235, 608, 608, 131, 132, 608, 608, 608, 542, 608,
    608, 608, 608, 608, 608, 608, 240, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 129, 294, 608, 293, 556, 295, 297, 296, 608,

    292, 608, 608, 608, 608, 608, 608, 129, 608, 608, 608, 298, 599, 599, 599,
    599, 608, 607, 294, 293, 608, 556, 295, 297, 296, 608, 131, 132, 608, 300,
    605, 299, 301, 608, 608, 608, 608, 298, 302, 606, 131, 132, 557, 608, 131,
    132, 608, 131, 132, 608, 131, 132, 608, 608, 608, 300, 299, 608, 301, 250,
    250, 131, 132, 302, 131, 132, 305, 307, 131, 132, 608, 303, 303, 303, 303,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 250, 608, 571, 608,
    608, 305, 608, 307, 608, 608, 131, 132, 608, 607,

    608, 608, 608, 608, 608, 608, 608, 308, 306, 608, 579, 608, 129, 608, 179,
    180, 608, 608, 608, 608, 608, 311, 608, 608, 608, 309, 608, 608, 608, 304,
    608, 608, 310, 308, 306, 608, 579, 608, 608, 608, 608, 608, 313, 312, 608,
    179, 180, 311, 608, 179, 180, 309, 179, 180, 608, 608, 608, 580, 310, 608,
    315, 608, 179, 180, 314, 608, 179, 180, 313, 312, 608, 179, 180, 608, 608,
    608, 608, 316, 179, 180, 268, 268, 608, 608, 179, 180, 315, 608, 608, 314,
    215, 216, 317, 317, 317, 317, 608, 608, 608, 215,

    216, 608, 608, 316, 608, 608, 608, 608, 608, 608, 608, 608, 270, 270, 323,
    268, 215, 216, 608, 608, 608, 608, 321, 608, 319, 319, 319, 319, 608, 608,
    608, 608, 608, 608, 608, 608, 131, 132, 608, 270, 608, 129, 608, 325, 608,
    608, 608, 608, 321, 322, 318, 608, 608, 608, 608, 608, 608, 608, 131, 132,
    608, 331, 608, 608, 608, 129, 608, 608, 608, 326, 608, 608, 608, 608, 322,
    608, 608, 280, 332, 332, 131, 132, 320, 324, 132, 334, 608, 331, 608, 330,
    608, 608, 608, 608, 326, 608, 608, 608, 608, 608,

    131, 132, 608, 129, 131, 132, 608, 131, 132, 338, 334, 608, 608, 608, 330,
    608, 131, 132, 339, 339, 608, 336, 131, 132, 608, 337, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 338, 608, 608, 608, 608, 342, 608, 608, 608, 608,
    341, 336, 608, 333, 132, 337, 343, 131, 132, 345, 131, 132, 608, 608, 131,
    132, 608, 608, 608, 608, 342, 608, 608, 344, 608, 608, 341, 608, 131, 132,
    608, 608, 343, 608, 608, 345, 347, 348, 349, 608, 608, 608, 354, 340, 132,
    346, 131, 132, 344, 608, 357, 131, 132, 351, 351,

    608, 131, 132, 608, 131, 132, 608, 608, 608, 608, 608, 608, 608, 354, 608,
    346, 350, 608, 608, 608, 357, 608, 608, 131, 132, 353, 179, 180, 608, 179,
    180, 608, 355, 608, 608, 608, 608, 356, 131, 132, 608, 350, 608, 608, 608,
    608, 131, 132, 608, 608, 608, 353, 358, 608, 608, 608, 608, 361, 355, 608,
    360, 608, 608, 356, 608, 608, 608, 608, 352, 132, 608, 131, 132, 359, 179,
    180, 608, 608, 358, 179, 180, 608, 608, 361, 608, 360, 608, 608, 608, 608,
    608, 608, 608, 179, 180, 608, 179, 180, 363, 359,

    608, 608, 179, 180, 608, 215, 216, 608, 608, 608, 608, 608, 608, 608, 362,
    179, 180, 608, 364, 371, 365, 608, 608, 608, 363, 608, 608, 608, 608, 608,
    608, 608, 323, 608, 608, 608, 608, 608, 608, 362, 608, 608, 608, 364, 215,
    216, 365, 368, 215, 216, 608, 131, 132, 375, 375, 608, 608, 369, 129, 608,
    608, 608, 374, 608, 608, 608, 608, 370, 608, 608, 131, 132, 608, 368, 608,
    608, 608, 608, 608, 131, 132, 608, 608, 369, 608, 608, 608, 608, 374, 332,
    332, 608, 370, 608, 379, 131, 132, 608, 131, 132,

    382, 377, 377, 377, 377, 608, 608, 608, 608, 608, 608, 608, 608, 608, 383,
    608, 332, 608, 339, 339, 379, 608, 608, 376, 132, 608, 382, 608, 608, 608,
    384, 384, 384, 384, 608, 381, 131, 132, 608, 388, 383, 608, 129, 608, 608,
    608, 608, 131, 132, 608, 608, 608, 608, 131, 132, 608, 386, 608, 391, 378,
    608, 381, 608, 608, 608, 388, 608, 608, 608, 608, 608, 387, 390, 339, 608,
    389, 608, 131, 132, 608, 608, 393, 386, 608, 391, 394, 608, 608, 385, 131,
    132, 608, 608, 395, 392, 608, 387, 608, 390, 129,

    608, 389, 608, 131, 132, 608, 131, 132, 608, 608, 608, 608, 131, 132, 608,
    351, 351, 131, 132, 608, 392, 608, 608, 608, 608, 608, 396, 397, 397, 397,
    397, 608, 608, 608, 608, 608, 131, 132, 608, 399, 399, 131, 132, 608, 608,
    131, 132, 608, 608, 608, 608, 608, 396, 131, 132, 608, 608, 608, 402, 608,
    608, 608, 608, 608, 608, 608, 351, 608, 608, 608, 131, 132, 608, 608, 608,
    608, 608, 400, 608, 608, 608, 608, 608, 608, 402, 398, 608, 405, 403, 608,
    406, 608, 129, 608, 608, 179, 180, 608, 608, 608,

    608, 608, 400, 608, 608, 408, 608, 404, 608, 401, 132, 608, 608, 405, 403,
    407, 406, 608, 409, 410, 608, 608, 608, 608, 608, 179, 180, 608, 608, 179,
    180, 408, 404, 608, 179, 180, 411, 608, 179, 180, 407, 608, 179, 180, 409,
    410, 608, 608, 608, 608, 608, 179, 180, 608, 608, 608, 608, 608, 608, 608,
    179, 180, 411, 131, 132, 608, 215, 216, 608, 608, 608, 412, 608, 608, 608,
    375, 375, 608, 608, 414, 608, 419, 608, 608, 215, 216, 608, 420, 420, 420,
    420, 608, 608, 608, 415, 608, 608, 412, 608, 608,

    608, 416, 608, 608, 608, 414, 608, 419, 131, 132, 608, 608, 608, 608, 608,
    131, 132, 608, 131, 132, 415, 608, 422, 608, 608, 608, 416, 426, 608, 424,
    131, 132, 427, 608, 131, 132, 608, 608, 608, 425, 608, 608, 608, 608, 608,
    421, 608, 375, 422, 608, 608, 608, 608, 426, 608, 424, 608, 427, 131, 132,
    608, 608, 131, 132, 608, 425, 131, 132, 429, 608, 608, 608, 608, 129, 131,
    132, 608, 430, 608, 428, 608, 608, 608, 608, 608, 131, 132, 608, 608, 608,
    608, 608, 432, 608, 429, 608, 608, 608, 608, 431,

    608, 608, 608, 430, 428, 608, 131, 132, 399, 399, 434, 131, 132, 608, 131,
    132, 608, 608, 432, 433, 435, 435, 435, 435, 431, 437, 437, 608, 608, 608,
    608, 131, 132, 608, 608, 608, 434, 608, 131, 132, 608, 608, 608, 608, 433,
    439, 608, 608, 608, 608, 131, 132, 608, 131, 132, 608, 608, 608, 440, 608,
    608, 608, 608, 608, 608, 608, 399, 441, 608, 608, 608, 439, 608, 608, 608,
    608, 608, 608, 436, 608, 608, 608, 608, 608, 440, 608, 447, 608, 442, 179,
    180, 608, 129, 441, 443, 438, 132, 444, 608, 608,

    608, 608, 179, 180, 608, 446, 608, 608, 608, 179, 180, 608, 447, 445, 442,
    448, 608, 608, 608, 608, 443, 608, 608, 444, 608, 179, 180, 608, 608, 608,
    608, 446, 215, 216, 608, 449, 179, 180, 445, 179, 180, 448, 179, 180, 457,
    179, 180, 608, 608, 608, 608, 451, 608, 608, 608, 608, 608, 608, 608, 608,
    449, 215, 216, 608, 608, 452, 131, 132, 608, 608, 457, 456, 608, 453, 608,
    608, 459, 451, 131, 132, 608, 131, 132, 608, 608, 608, 608, 608, 608, 131,
    132, 452, 608, 462, 608, 460, 608, 456, 608, 453,

    608, 461, 459, 608, 608, 608, 608, 608, 608, 131, 132, 608, 131, 132, 463,
    131, 132, 608, 131, 132, 608, 460, 608, 465, 465, 608, 461, 608, 608, 437,
    437, 608, 608, 608, 131, 132, 608, 608, 608, 608, 463, 467, 467, 467, 467,
    131, 132, 608, 131, 132, 608, 608, 608, 608, 131, 132, 464, 608, 608, 608,
    131, 132, 608, 608, 608, 131, 132, 608, 131, 132, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 464, 131, 132, 437, 608, 608, 179, 180, 608,
    608, 608, 608, 466, 132, 469, 608, 608, 608, 468,

    608, 608, 608, 608, 608, 608, 608, 608, 470, 608, 129, 608, 179, 180, 608,
    608, 608, 608, 608, 608, 608, 469, 608, 471, 215, 216, 608, 608, 472, 608,
    608, 608, 179, 180, 470, 475, 475, 473, 474, 608, 608, 608, 608, 608, 608,
    608, 608, 479, 608, 471, 608, 608, 179, 180, 472, 608, 608, 608, 608, 608,
    179, 180, 473, 608, 474, 179, 180, 478, 608, 179, 180, 483, 608, 479, 608,
    608, 215, 216, 484, 480, 608, 608, 179, 180, 608, 608, 485, 608, 608, 131,
    132, 608, 608, 478, 608, 608, 608, 483, 608, 608,

    608, 608, 131, 132, 480, 476, 132, 608, 488, 608, 131, 132, 608, 608, 608,
    608, 608, 131, 132, 608, 608, 608, 608, 490, 608, 465, 465, 608, 608, 489,
    437, 437, 491, 608, 488, 608, 608, 493, 493, 493, 493, 608, 467, 467, 467,
    467, 608, 486, 132, 490, 608, 608, 492, 608, 489, 608, 131, 132, 491, 608,
    131, 132, 608, 608, 608, 608, 608, 608, 608, 131, 132, 608, 608, 608, 131,
    132, 608, 492, 608, 608, 495, 131, 132, 496, 131, 132, 608, 608, 608, 497,
    608, 608, 608, 608, 608, 494, 608, 465, 608, 608,

    468, 608, 608, 515, 608, 608, 495, 608, 608, 496, 608, 608, 608, 179, 180,
    497, 504, 475, 475, 608, 608, 608, 608, 129, 179, 180, 608, 179, 180, 498,
    498, 498, 498, 179, 180, 608, 608, 608, 179, 180, 503, 608, 504, 499, 608,
    500, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 179, 180, 475, 608,
    508, 131, 132, 608, 608, 608, 503, 608, 608, 499, 608, 500, 516, 132, 608,
    505, 608, 608, 608, 608, 608, 608, 131, 132, 129, 511, 508, 501, 608, 608,
    608, 513, 608, 608, 608, 608, 514, 131, 132, 484,

    505, 608, 608, 608, 608, 608, 131, 132, 608, 608, 608, 511, 608, 608, 608,
    608, 608, 513, 517, 608, 608, 608, 514, 608, 608, 129, 608, 131, 132, 608,
    131, 132, 608, 608, 608, 608, 608, 608, 131, 132, 608, 131, 132, 608, 517,
    608, 608, 521, 608, 608, 608, 523, 522, 608, 608, 608, 608, 608, 528, 608,
    608, 608, 608, 608, 608, 131, 132, 608, 608, 608, 179, 180, 608, 521, 179,
    180, 608, 523, 522, 526, 608, 179, 180, 608, 528, 608, 131, 132, 530, 608,
    608, 608, 540, 608, 131, 132, 608, 131, 132, 608,

    608, 608, 608, 608, 526, 131, 132, 538, 608, 531, 131, 132, 608, 530, 608,
    131, 132, 539, 540, 131, 132, 608, 608, 608, 608, 608, 608, 608, 608, 131,
    132, 542, 515, 538, 608, 531, 608, 608, 608, 608, 608, 608, 608, 539, 608,
    131, 132, 608, 608, 608, 608, 608, 608, 131, 132, 608, 608, 608, 129, 549,
    608, 608, 548, 131, 132, 554, 608, 608, 608, 608, 608, 608, 608, 608, 131,
    132, 608, 608, 608, 608, 608, 555, 608, 571, 608, 549, 608, 608, 548, 608,
    608, 554, 608, 608, 608, 608, 131, 132, 608, 608,

    543, 132, 608, 608, 131, 132, 559, 555, 608, 131, 132, 608, 131, 132, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 542, 608, 608, 131, 132,
    608, 608, 559, 131, 132, 608, 608, 608, 131, 132, 608, 608, 131, 132, 608,
    608, 131, 132, 608, 565, 608, 129, 572, 132, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 571, 574, 574, 608, 608, 595, 595, 608, 608, 608,
    565, 608, 608, 582, 582, 582, 582, 599, 599, 599, 599, 131, 132, 608, 608,
    608, 129, 608, 608, 608, 608, 608, 608, 608, 608,

    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 575, 608, 608, 608, 596, 45,  45,  45,  93,
    93,  93,  120, 608, 120, 122, 608, 122, 160, 608, 160, 162, 608, 162, 164,
    608, 164, 166, 608, 166, 168, 608, 168, 171, 608, 171, 173, 608, 173, 194,
    608, 194, 196, 608, 196, 207, 608, 207, 209, 608, 209, 220, 608, 220, 253,
    608, 253, 254, 608, 254, 255, 608, 255, 11,  608,

    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608};

static const flex_int16_t yy_chk[3774] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    2,   3,   27,  6,   27,  2,   327, 3,   6,   4,   2,   2,   2,   2,   2,
    4,   10,  627, 624, 621, 4,   10,  20,  286, 20,  613,

    20,  20,  20,  20,  23,  327, 23,  607, 23,  23,  23,  23,  58,  596, 58,
    328, 58,  58,  58,  58,  61,  592, 61,  286, 61,  61,  61,  61,  86,  580,
    86,  575, 86,  86,  86,  86,  557, 547, 27,  27,  328, 536, 533, 2,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,

    5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
    5,   5,   5,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,   7,
    7,   7,   7,   7,   7,   7,   7,   7,   7,   158, 158, 158, 158, 14,  21,
    21,  25,  25,  52,  63,  63,  82,  21,  100, 21,  335, 21,  21,  21,  21,
    118, 22,  510, 22,  7,   22,  22,  22,  22,  24,  40,  24,  127, 24,  24,
    24,  24,  133, 501, 494, 335, 40,  40,  40,  40,  65,  468, 65,  169, 7,
    7,   8,   8,   8,   8,   8,   8,   8,   8,   8,

    8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,   14,  413, 21,
    65,  25,  52,  436, 63,  82,  421, 100, 22,  22,  272, 272, 272, 272, 118,
    398, 24,  24,  291, 291, 291, 291, 8,   413, 40,  65,  127, 303, 303, 303,
    303, 133, 65,  65,  89,  385, 89,  378, 89,  89,  89,  89,  169, 317, 317,
    317, 317, 8,   8,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,
    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,
    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,

    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,
    9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,   9,
    9,   9,   9,   9,   9,   9,   9,   9,   26,  367, 26,  29,  329, 29,  192,
    28,  205, 28,  366, 91,  91,  320, 372, 29,  318, 30,  423, 30,  104, 373,
    104, 26,  104, 104, 104, 104, 304, 26,  26,  292, 26,  28,  109, 109, 366,
    287, 30,  157, 372, 29,  30,  423, 31,  235, 31,  373, 273, 26,  157, 157,
    157, 157, 26,  26,  31,  26,  66,  28,  66,  454,

    26,  26,  30,  29,  29,  235, 30,  28,  28,  455, 32,  31,  32,  192, 31,
    205, 209, 30,  30,  91,  31,  34,  477, 34,  454, 32,  33,  380, 33,  529,
    207, 235, 66,  206, 455, 32,  31,  34,  529, 31,  32,  36,  109, 36,  31,
    31,  157, 477, 35,  33,  35,  32,  235, 380, 37,  33,  37,  66,  66,  66,
    36,  32,  500, 34,  35,  32,  37,  36,  417, 196, 35,  194, 32,  32,  193,
    33,  319, 319, 319, 319, 33,  173, 171, 34,  34,  170, 36,  500, 33,  33,
    35,  159, 37,  36,  417, 43,  35,  43,  529, 43,

    43,  43,  43,  36,  36,  377, 377, 377, 377, 134, 35,  35,  384, 384, 384,
    384, 37,  37,  38,  38,  38,  128, 38,  38,  38,  38,  39,  39,  39,  38,
    39,  39,  39,  39,  44,  44,  44,  39,  44,  44,  44,  44,  60,  418, 60,
    44,  60,  60,  60,  60,  122, 450, 59,  59,  67,  38,  67,  43,  43,  527,
    59,  458, 59,  39,  59,  59,  59,  59,  62,  418, 62,  44,  62,  62,  62,
    62,  68,  450, 68,  120, 69,  481, 69,  70,  527, 70,  71,  458, 71,  482,
    72,  119, 72,  73,  487, 73,  116, 499, 103, 70,

    280, 68,  102, 71,  60,  60,  69,  481, 74,  73,  74,  502, 75,  101, 75,
    482, 67,  67,  96,  72,  487, 506, 59,  499, 280, 70,  93,  68,  93,  71,
    62,  62,  69,  92,  280, 73,  85,  502, 68,  68,  74,  75,  69,  69,  72,
    70,  70,  506, 71,  71,  280, 84,  72,  72,  550, 73,  73,  76,  76,  76,
    280, 76,  76,  76,  76,  74,  75,  83,  76,  280, 74,  74,  78,  64,  75,
    75,  77,  77,  77,  550, 77,  77,  77,  77,  558, 87,  87,  77,  93,  93,
    57,  54,  507, 87,  76,  87,  509, 87,  87,  87,

    87,  88,  512, 88,  563, 88,  88,  88,  88,  558, 90,  53,  90,  77,  90,
    90,  90,  90,  507, 94,  94,  94,  509, 94,  94,  94,  94,  48,  512, 563,
    94,  95,  95,  95,  518, 95,  95,  95,  95,  105, 105, 110, 95,  110, 129,
    520, 129, 105, 47,  105, 41,  105, 105, 105, 105, 87,  94,  524, 19,  111,
    518, 111, 16,  88,  88,  519, 519, 532, 95,  15,  11,  520, 90,  90,  106,
    534, 106, 566, 106, 106, 106, 106, 107, 524, 107, 111, 107, 107, 107, 107,
    108, 0,   108, 532, 108, 108, 108, 108, 112, 537,

    112, 534, 566, 110, 110, 577, 129, 129, 113, 105, 113, 111, 124, 544, 124,
    0,   124, 124, 124, 124, 0,   111, 111, 112, 113, 537, 0,   114, 114, 114,
    577, 114, 114, 114, 114, 519, 106, 106, 114, 544, 115, 115, 115, 0,   115,
    115, 115, 115, 586, 112, 113, 115, 108, 108, 223, 223, 397, 397, 397, 397,
    112, 112, 0,   323, 114, 0,   223, 223, 223, 223, 113, 113, 0,   586, 125,
    551, 125, 115, 125, 125, 125, 125, 130, 0,   130, 323, 130, 130, 130, 130,
    131, 131, 131, 552, 131, 131, 131, 131, 132, 132,

    132, 551, 132, 132, 132, 132, 135, 545, 135, 132, 136, 323, 136, 137, 137,
    138, 545, 138, 140, 552, 140, 137, 556, 137, 223, 560, 136, 131, 561, 135,
    562, 564, 323, 598, 139, 132, 139, 141, 0,   141, 143, 568, 143, 0,   130,
    130, 138, 0,   556, 140, 0,   560, 136, 141, 561, 135, 562, 564, 598, 139,
    142, 139, 142, 143, 144, 569, 144, 568, 135, 135, 0,   138, 136, 136, 140,
    142, 545, 138, 138, 141, 140, 140, 0,   137, 137, 139, 145, 139, 145, 143,
    144, 569, 152, 142, 152, 0,   139, 139, 146, 141,

    141, 142, 143, 143, 570, 146, 152, 146, 535, 535, 147, 145, 147, 149, 0,
    149, 144, 150, 142, 150, 573, 146, 142, 142, 147, 0,   144, 144, 148, 148,
    570, 153, 152, 153, 535, 0,   148, 145, 148, 156, 147, 156, 154, 150, 154,
    149, 573, 146, 145, 145, 147, 153, 0,   0,   152, 152, 155, 155, 0,   151,
    535, 151, 156, 0,   155, 147, 155, 146, 146, 150, 149, 154, 147, 147, 151,
    149, 149, 153, 535, 150, 150, 576, 177, 151, 177, 163, 151, 163, 156, 163,
    163, 163, 163, 153, 153, 0,   154, 578, 148, 148,

    151, 156, 156, 0,   154, 154, 0,   576, 182, 151, 182, 174, 151, 174, 0,
    174, 174, 174, 174, 0,   579, 151, 151, 578, 0,   0,   155, 155, 175, 183,
    175, 183, 175, 175, 175, 175, 178, 0,   178, 0,   178, 178, 178, 178, 177,
    177, 579, 163, 163, 179, 179, 179, 0,   179, 179, 179, 179, 180, 180, 180,
    0,   180, 180, 180, 180, 184, 0,   184, 180, 581, 182, 182, 0,   185, 0,
    185, 186, 0,   186, 187, 0,   187, 420, 420, 420, 420, 179, 188, 186, 188,
    0,   183, 183, 185, 180, 581, 187, 0,   178, 178,

    200, 0,   200, 188, 189, 0,   189, 188, 583, 191, 0,   191, 567, 567, 186,
    435, 435, 435, 435, 185, 584, 191, 187, 493, 493, 493, 493, 184, 184, 188,
    587, 189, 589, 188, 583, 185, 185, 0,   186, 186, 0,   187, 187, 190, 0,
    190, 584, 191, 593, 188, 188, 498, 498, 498, 498, 585, 587, 189, 589, 0,
    190, 0,   200, 200, 585, 597, 189, 189, 601, 0,   190, 191, 191, 197, 593,
    197, 602, 197, 197, 197, 197, 0,   567, 198, 603, 198, 190, 198, 198, 198,
    198, 597, 0,   201, 601, 201, 190, 201, 201, 201,

    201, 213, 602, 213, 0,   190, 190, 202, 202, 202, 603, 202, 202, 202, 202,
    203, 203, 203, 0,   203, 203, 203, 203, 210, 585, 210, 203, 210, 210, 210,
    210, 211, 217, 211, 217, 211, 211, 211, 211, 0,   0,   214, 230, 214, 202,
    214, 214, 214, 214, 230, 0,   230, 203, 0,   0,   201, 201, 0,   0,   217,
    219, 484, 219, 213, 213, 215, 215, 215, 515, 215, 215, 215, 215, 216, 216,
    216, 0,   216, 216, 216, 216, 221, 221, 484, 216, 217, 218, 219, 218, 221,
    515, 221, 0,   0,   217, 217, 0,   222, 222, 225,

    218, 225, 215, 214, 214, 222, 0,   222, 0,   484, 216, 230, 230, 219, 0,
    226, 515, 226, 225, 227, 0,   227, 219, 219, 588, 588, 218, 224, 224, 224,
    484, 224, 224, 224, 224, 0,   0,   515, 224, 0,   0,   228, 0,   228, 225,
    226, 0,   0,   218, 218, 590, 221, 221, 228, 231, 227, 231, 228, 229, 590,
    229, 225, 225, 232, 224, 232, 0,   222, 222, 0,   226, 0,   229, 233, 231,
    233, 0,   226, 226, 228, 227, 227, 227, 228, 238, 0,   238, 234, 0,   234,
    236, 0,   236, 232, 588, 0,   0,   233, 229, 0,

    231, 234, 0,   228, 228, 0,   239, 238, 239, 582, 582, 582, 582, 0,   0,
    236, 231, 231, 232, 590, 229, 229, 0,   233, 0,   232, 232, 234, 0,   0,
    240, 240, 0,   238, 0,   233, 233, 239, 0,   0,   0,   236, 240, 240, 240,
    240, 238, 238, 604, 234, 234, 0,   236, 236, 237, 237, 237, 604, 237, 237,
    237, 237, 239, 0,   242, 237, 242, 0,   239, 239, 241, 241, 241, 542, 241,
    241, 241, 241, 243, 0,   243, 241, 244, 0,   244, 245, 0,   245, 246, 0,
    246, 237, 243, 0,   242, 542, 243, 245, 244, 247,

    240, 247, 248, 0,   248, 0,   249, 241, 249, 0,   0,   246, 599, 599, 599,
    599, 0,   604, 243, 242, 0,   542, 243, 245, 244, 0,   242, 242, 0,   248,
    605, 247, 249, 0,   252, 0,   252, 246, 249, 605, 243, 243, 542, 0,   244,
    244, 0,   245, 245, 0,   246, 246, 257, 0,   257, 248, 247, 0,   249, 250,
    250, 247, 247, 249, 248, 248, 252, 257, 249, 249, 0,   250, 250, 250, 250,
    251, 251, 251, 0,   251, 251, 251, 251, 256, 0,   256, 251, 258, 571, 258,
    259, 252, 259, 257, 0,   0,   252, 252, 0,   605,

    260, 0,   260, 0,   262, 0,   262, 259, 256, 261, 571, 261, 251, 0,   257,
    257, 263, 0,   263, 0,   0,   262, 264, 0,   264, 260, 0,   0,   265, 250,
    265, 0,   261, 259, 256, 0,   571, 266, 0,   266, 0,   0,   264, 263, 0,
    256, 256, 262, 0,   258, 258, 260, 259, 259, 267, 0,   267, 571, 261, 0,
    266, 0,   260, 260, 265, 0,   262, 262, 264, 263, 0,   261, 261, 0,   276,
    0,   276, 267, 263, 263, 268, 268, 0,   0,   264, 264, 266, 0,   0,   265,
    265, 265, 268, 268, 268, 268, 274, 0,   274, 266,

    266, 0,   0,   267, 269, 269, 269, 0,   269, 269, 269, 269, 270, 270, 277,
    269, 267, 267, 275, 0,   275, 277, 274, 277, 270, 270, 270, 270, 271, 271,
    271, 0,   271, 271, 271, 271, 276, 276, 279, 271, 279, 269, 278, 278, 278,
    283, 0,   283, 274, 275, 268, 0,   0,   0,   285, 0,   285, 0,   274, 274,
    282, 283, 282, 0,   0,   271, 281, 281, 281, 279, 281, 281, 281, 281, 275,
    0,   0,   281, 284, 284, 275, 275, 270, 277, 277, 285, 284, 283, 284, 282,
    288, 0,   288, 289, 279, 289, 0,   290, 0,   290,

    279, 279, 0,   281, 278, 278, 0,   283, 283, 290, 285, 295, 0,   295, 282,
    0,   285, 285, 293, 293, 0,   288, 282, 282, 0,   289, 293, 0,   293, 294,
    0,   294, 0,   0,   296, 290, 296, 0,   0,   297, 295, 297, 298, 0,   298,
    294, 288, 0,   284, 284, 289, 296, 288, 288, 298, 289, 289, 0,   0,   290,
    290, 299, 0,   299, 309, 295, 309, 306, 297, 306, 0,   294, 0,   295, 295,
    0,   300, 296, 300, 0,   298, 300, 300, 300, 301, 0,   301, 306, 293, 293,
    299, 294, 294, 297, 0,   309, 296, 296, 302, 302,

    0,   297, 297, 0,   298, 298, 302, 0,   302, 305, 0,   305, 307, 306, 307,
    299, 301, 308, 0,   308, 309, 0,   0,   299, 299, 305, 309, 309, 0,   306,
    306, 312, 307, 312, 313, 0,   313, 308, 300, 300, 310, 301, 310, 314, 0,
    314, 301, 301, 0,   0,   0,   305, 310, 311, 0,   311, 0,   313, 307, 0,
    312, 0,   0,   308, 0,   0,   0,   0,   302, 302, 0,   305, 305, 311, 307,
    307, 0,   0,   310, 308, 308, 0,   315, 313, 315, 312, 316, 0,   316, 321,
    0,   321, 0,   312, 312, 0,   313, 313, 316, 311,

    0,   0,   310, 310, 0,   314, 314, 0,   322, 0,   322, 0,   0,   0,   315,
    311, 311, 326, 321, 326, 322, 324, 324, 324, 316, 324, 324, 324, 324, 0,
    0,   0,   324, 325, 0,   325, 330, 0,   330, 315, 0,   0,   0,   321, 315,
    315, 322, 325, 316, 316, 0,   321, 321, 331, 331, 0,   0,   325, 324, 0,
    0,   331, 330, 331, 0,   0,   0,   325, 0,   0,   322, 322, 0,   325, 334,
    0,   334, 0,   0,   326, 326, 0,   0,   325, 0,   337, 0,   337, 330, 332,
    332, 338, 325, 338, 334, 325, 325, 0,   330, 330,

    337, 332, 332, 332, 332, 333, 333, 333, 0,   333, 333, 333, 333, 0,   338,
    336, 333, 336, 339, 339, 334, 0,   0,   331, 331, 0,   337, 342, 0,   342,
    339, 339, 339, 339, 0,   336, 334, 334, 0,   342, 338, 341, 333, 341, 345,
    0,   345, 337, 337, 0,   344, 0,   344, 338, 338, 343, 341, 343, 345, 332,
    0,   336, 340, 340, 340, 342, 340, 340, 340, 340, 0,   341, 344, 340, 346,
    343, 346, 336, 336, 347, 0,   347, 341, 348, 345, 348, 0,   0,   339, 342,
    342, 349, 0,   349, 346, 0,   341, 0,   344, 340,

    0,   343, 0,   341, 341, 0,   345, 345, 350, 0,   350, 0,   344, 344, 0,
    351, 351, 343, 343, 0,   346, 0,   0,   0,   0,   0,   350, 351, 351, 351,
    351, 0,   0,   354, 0,   354, 346, 346, 0,   353, 353, 347, 347, 0,   0,
    348, 348, 353, 0,   353, 0,   0,   350, 349, 349, 352, 352, 352, 354, 352,
    352, 352, 352, 355, 0,   355, 352, 357, 0,   357, 350, 350, 356, 0,   356,
    0,   358, 353, 358, 0,   359, 0,   359, 0,   354, 351, 0,   357, 355, 360,
    358, 360, 352, 0,   0,   354, 354, 0,   361, 0,

    361, 364, 353, 364, 362, 360, 362, 356, 0,   353, 353, 0,   0,   357, 355,
    359, 358, 0,   361, 362, 0,   0,   363, 0,   363, 355, 355, 0,   0,   357,
    357, 360, 356, 0,   356, 356, 363, 0,   358, 358, 359, 0,   359, 359, 361,
    362, 365, 0,   365, 0,   0,   360, 360, 368, 0,   368, 374, 0,   374, 0,
    361, 361, 363, 364, 364, 0,   362, 362, 369, 0,   369, 365, 370, 0,   370,
    375, 375, 0,   0,   368, 0,   374, 0,   0,   363, 363, 0,   375, 375, 375,
    375, 0,   0,   0,   369, 0,   379, 365, 379, 0,

    386, 370, 386, 0,   383, 368, 383, 374, 365, 365, 0,   0,   381, 0,   381,
    368, 368, 0,   374, 374, 369, 0,   379, 382, 0,   382, 370, 383, 0,   381,
    369, 369, 386, 0,   370, 370, 376, 376, 376, 382, 376, 376, 376, 376, 388,
    375, 388, 376, 379, 387, 0,   387, 389, 383, 389, 381, 0,   386, 379, 379,
    0,   0,   386, 386, 0,   382, 383, 383, 388, 390, 0,   390, 0,   376, 381,
    381, 391, 389, 391, 387, 0,   0,   0,   0,   0,   382, 382, 0,   392, 0,
    392, 396, 391, 396, 388, 0,   0,   0,   0,   390,

    0,   0,   0,   389, 387, 0,   388, 388, 399, 399, 396, 387, 387, 0,   389,
    389, 0,   0,   391, 392, 399, 399, 399, 399, 390, 400, 400, 402, 0,   402,
    0,   390, 390, 400, 0,   400, 396, 0,   391, 391, 403, 0,   403, 0,   392,
    402, 0,   404, 0,   404, 392, 392, 0,   396, 396, 401, 401, 401, 403, 401,
    401, 401, 401, 405, 0,   405, 401, 404, 0,   0,   410, 402, 410, 0,   406,
    0,   406, 407, 399, 407, 409, 0,   409, 408, 403, 408, 410, 0,   405, 402,
    402, 0,   401, 404, 406, 400, 400, 407, 0,   411,

    0,   411, 403, 403, 412, 409, 412, 0,   0,   404, 404, 0,   410, 408, 405,
    411, 425, 0,   425, 422, 406, 422, 0,   407, 0,   405, 405, 414, 0,   414,
    0,   409, 410, 410, 0,   412, 406, 406, 408, 407, 407, 411, 409, 409, 422,
    408, 408, 419, 0,   419, 415, 414, 415, 416, 0,   416, 424, 0,   424, 0,
    412, 411, 411, 0,   0,   415, 412, 412, 0,   0,   422, 419, 427, 416, 427,
    0,   424, 414, 425, 425, 0,   422, 422, 426, 0,   426, 428, 0,   428, 414,
    414, 415, 429, 429, 429, 426, 0,   419, 430, 416,

    430, 427, 424, 431, 0,   431, 432, 0,   432, 419, 419, 0,   415, 415, 430,
    416, 416, 0,   424, 424, 433, 426, 433, 434, 434, 439, 427, 439, 0,   437,
    437, 434, 0,   434, 427, 427, 0,   0,   0,   0,   430, 437, 437, 437, 437,
    426, 426, 0,   428, 428, 440, 0,   440, 0,   429, 429, 433, 0,   0,   0,
    430, 430, 447, 0,   447, 431, 431, 0,   432, 432, 441, 0,   441, 438, 438,
    438, 0,   438, 438, 438, 438, 433, 433, 433, 438, 0,   0,   439, 439, 0,
    442, 0,   442, 434, 434, 441, 0,   0,   443, 437,

    443, 0,   0,   444, 0,   444, 0,   445, 442, 445, 438, 0,   440, 440, 448,
    0,   448, 0,   0,   0,   446, 441, 446, 443, 447, 447, 0,   452, 444, 452,
    0,   0,   441, 441, 442, 449, 449, 445, 446, 0,   451, 0,   451, 449, 0,
    449, 0,   452, 453, 443, 453, 0,   442, 442, 444, 456, 0,   456, 0,   0,
    443, 443, 445, 0,   446, 444, 444, 451, 0,   445, 445, 456, 0,   452, 0,
    0,   448, 448, 457, 453, 0,   0,   446, 446, 0,   457, 457, 457, 0,   452,
    452, 0,   0,   451, 459, 0,   459, 456, 460, 0,

    460, 0,   451, 451, 453, 449, 449, 461, 459, 461, 453, 453, 462, 0,   462,
    0,   0,   456, 456, 464, 0,   464, 463, 461, 463, 465, 465, 0,   0,   460,
    467, 467, 462, 0,   459, 0,   0,   465, 465, 465, 465, 0,   467, 467, 467,
    467, 0,   457, 457, 461, 0,   470, 463, 470, 460, 0,   459, 459, 462, 0,
    460, 460, 469, 0,   469, 471, 0,   471, 0,   461, 461, 472, 0,   472, 462,
    462, 473, 463, 473, 0,   469, 464, 464, 471, 463, 463, 466, 466, 466, 472,
    466, 466, 466, 466, 474, 465, 474, 466, 0,   479,

    467, 479, 0,   490, 0,   0,   469, 0,   0,   471, 490, 0,   490, 470, 470,
    472, 479, 475, 475, 0,   478, 0,   478, 466, 469, 469, 0,   471, 471, 475,
    475, 475, 475, 472, 472, 483, 0,   483, 473, 473, 478, 0,   479, 475, 480,
    475, 480, 476, 476, 476, 0,   476, 476, 476, 476, 0,   474, 474, 476, 0,
    483, 479, 479, 0,   0,   485, 478, 485, 492, 475, 492, 475, 490, 490, 0,
    480, 489, 0,   489, 488, 0,   488, 478, 478, 476, 485, 483, 475, 486, 486,
    486, 488, 486, 486, 486, 486, 489, 483, 483, 486,

    480, 0,   0,   491, 0,   491, 480, 480, 495, 0,   495, 485, 496, 0,   496,
    0,   0,   488, 491, 497, 0,   497, 489, 0,   503, 486, 503, 485, 485, 0,
    492, 492, 504, 0,   504, 505, 0,   505, 489, 489, 0,   488, 488, 511, 491,
    511, 0,   503, 508, 0,   508, 505, 504, 517, 0,   517, 0,   513, 511, 513,
    0,   0,   0,   0,   0,   491, 491, 523, 0,   523, 495, 495, 0,   503, 496,
    496, 0,   505, 504, 508, 0,   497, 497, 514, 511, 514, 503, 503, 513, 0,
    0,   521, 523, 521, 504, 504, 0,   505, 505, 0,

    0,   522, 0,   522, 508, 511, 511, 521, 0,   514, 508, 508, 528, 513, 528,
    517, 517, 522, 523, 513, 513, 516, 516, 516, 0,   516, 516, 516, 516, 523,
    523, 526, 516, 521, 531, 514, 531, 0,   526, 0,   526, 0,   530, 522, 530,
    514, 514, 540, 0,   540, 538, 0,   538, 521, 521, 0,   0,   0,   516, 531,
    0,   0,   530, 522, 522, 538, 539, 0,   539, 0,   0,   549, 0,   549, 528,
    528, 554, 0,   554, 0,   548, 539, 548, 565, 555, 531, 555, 0,   530, 0,
    565, 538, 565, 0,   0,   0,   531, 531, 0,   0,

    526, 526, 0,   0,   530, 530, 548, 539, 0,   540, 540, 0,   538, 538, 543,
    543, 543, 0,   543, 543, 543, 543, 0,   0,   559, 543, 559, 0,   539, 539,
    0,   0,   548, 549, 549, 0,   0,   0,   554, 554, 0,   0,   548, 548, 0,
    0,   555, 555, 0,   559, 0,   543, 565, 565, 572, 572, 572, 0,   572, 572,
    572, 572, 0,   0,   0,   572, 574, 574, 0,   0,   595, 595, 0,   0,   0,
    559, 0,   0,   574, 574, 574, 574, 595, 595, 595, 595, 559, 559, 0,   0,
    0,   572, 0,   0,   0,   0,   0,   0,   0,   0,

    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    0,   0,   0,   0,   0,   0,   574, 0,   0,   0,   595, 609, 609, 609, 610,
    610, 610, 611, 0,   611, 612, 0,   612, 614, 0,   614, 615, 0,   615, 616,
    0,   616, 617, 0,   617, 618, 0,   618, 619, 0,   619, 620, 0,   620, 622,
    0,   622, 623, 0,   623, 625, 0,   625, 626, 0,   626, 628, 0,   628, 629,
    0,   629, 630, 0,   630, 631, 0,   631, 608, 608,

    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608,
    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608};

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 0;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "pplex.l"
/*
 * Copyright (C) 2001-2009 Keisuke Nishida
 * Copyright (C) 2007-2009 Roger While
 * Copyright (C) 2021-2022 TOKYO SYSTEM HOUSE Co., Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software; see the file COPYING.  If not, write to
 * the Free Software Foundation, 51 Franklin Street, Fifth Floor
 * Boston, MA 02110-1301 USA
 */
#line 31 "pplex.l"

#include "config.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
#include <ctype.h>
#include <errno.h>
#include <sys/stat.h>
#include <sys/types.h>

#include "cobj.h"
#include "ppparse.h"

enum {
  CB_COMPILE_STATUS_NONE,
  CB_COMPILE_STATUS_TRUE,
  CB_COMPILE_STATUS_FALSE,
  CB_COMPILE_STATUS_FALSE_END,
  CB_COMPILE_STATUS_TRUE_ELSE,
  CB_COMPILE_STATUS_FALSE_ELSE,
  CB_COMPILE_STATUS_ERROR
};

static char *plexbuff1 = NULL;
static char *plexbuff2 = NULL;
static size_t newline_count = 0;
static size_t within_comment = 0;
static size_t inside_bracket = 0;
static size_t consecutive_quotation = 0;
static int quotation_mark = 0;
static int last_line_1 = -1;
static int last_line_2 = -1;

/* for COBOL68 style COPY in data description entry */
static int suppress_echo = 0;
static int current_division = PP_OUT_OF_DIVISION;
static int omit_data_entry_name = 0;
static int omit_data_redef_name = 0;

#define MAX_DEPTH 10
static int cb_compile_status = CB_COMPILE_STATUS_NONE;
static int cb_compile_status_list[MAX_DEPTH];
static int compile_directive_depth = -1;

static struct cb_replace_list *current_replace_list = NULL;

static struct cb_replace_list *current_copy_replace_list = NULL;

static struct cb_joining_ext *current_joining_ext = NULL;

static struct cb_text_list *text_queue1 = NULL; /* for COPY REPLACING */
static struct cb_text_list *text_queue2 = NULL; /* for REPLACE */

static struct copy_info {
  struct copy_info *next;
  char *file;
  int line;
  int replacing;
  int joining;
  int quotation_mark;
  YY_BUFFER_STATE buffer;
} *copy_stack = NULL;

#define YY_INPUT(buf, result, max_size) result = ppinput(buf, max_size);

static int ppinput(char *buf, int max_size);
static void ppecho(const char *text);

#ifdef I18N_UTF8
static void convert_ucs_hyphen_minus(char *namebuf);
#endif /*I18N_UTF8*/

static void ppecho_dataname(char *datanamebuf);

static void switch_to_buffer(const int lineno, const char *filename,
                             YY_BUFFER_STATE buffer);

#line 1846 "pplex.c"

#line 1848 "pplex.c"

#define INITIAL 0
#define PROCESS_STATE 1
#define COPY_STATE 2
#define PSEUDO_STATE 3
#define DATANAME_JOIN_STATE 4

#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void *
#endif

static int yy_init_globals(void);

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylex_destroy(void);

int yyget_debug(void);

void yyset_debug(int debug_flag);

YY_EXTRA_TYPE yyget_extra(void);

void yyset_extra(YY_EXTRA_TYPE user_defined);

FILE *yyget_in(void);

void yyset_in(FILE *_in_str);

FILE *yyget_out(void);

void yyset_out(FILE *_out_str);

int yyget_leng(void);

char *yyget_text(void);

int yyget_lineno(void);

void yyset_lineno(int _line_number);

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

#ifndef YY_NO_UNPUT

static void yyunput(int c, char *buf_ptr);

#endif

#ifndef yytext_ptr
static void yy_flex_strncpy(char *, const char *, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *);
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif

/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                   \
  do {                                                                         \
    if (fwrite(yytext, (size_t)yyleng, 1, yyout)) {                            \
    }                                                                          \
  } while (0)
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                        \
  if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive) {                           \
    int c = '*';                                                               \
    int n;                                                                     \
    for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)     \
      buf[n] = (char)c;                                                        \
    if (c == '\n')                                                             \
      buf[n++] = (char)c;                                                      \
    if (c == EOF && ferror(yyin))                                              \
      YY_FATAL_ERROR("input in flex scanner failed");                          \
    result = n;                                                                \
  } else {                                                                     \
    errno = 0;                                                                 \
    while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 &&    \
           ferror(yyin)) {                                                     \
      if (errno != EINTR) {                                                    \
        YY_FATAL_ERROR("input in flex scanner failed");                        \
        break;                                                                 \
      }                                                                        \
      errno = 0;                                                               \
      clearerr(yyin);                                                          \
    }                                                                          \
  }

#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
#endif

/* end tables serialization structures and prototypes */

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1

extern int yylex(void);

#define YY_DECL int yylex(void)
#endif /* !YY_DECL */

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif

#define YY_RULE_SETUP                                                          \
  if (yyleng > 0)                                                              \
    YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (yytext[yyleng - 1] == '\n');        \
  YY_USER_ACTION

/** The main scanner function which does all the work.
 */
YY_DECL {
  yy_state_type yy_current_state;
  char *yy_cp, *yy_bp;
  int yy_act;

  if (!(yy_init)) {
    (yy_init) = 1;

#ifdef YY_USER_INIT
    YY_USER_INIT;
#endif

    if (!(yy_start))
      (yy_start) = 1; /* first start state */

    if (!yyin)
      yyin = stdin;

    if (!yyout)
      yyout = stdout;

    if (!YY_CURRENT_BUFFER) {
      yyensure_buffer_stack();
      YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_load_buffer_state();
  }

  {
#line 126 "pplex.l"

#line 2070 "pplex.c"

    while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
    {
      yy_cp = (yy_c_buf_p);

      /* Support of yytext. */
      *yy_cp = (yy_hold_char);

      /* yy_bp points to the position in yy_ch_buf of the start of
       * the current run.
       */
      yy_bp = yy_cp;

      yy_current_state = (yy_start);
      yy_current_state += YY_AT_BOL();
    yy_match:
      do {
        YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
        if (yy_accept[yy_current_state]) {
          (yy_last_accepting_state) = yy_current_state;
          (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
          yy_current_state = (int)yy_def[yy_current_state];
          if (yy_current_state >= 609)
            yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
        ++yy_cp;
      } while (yy_current_state != 608);
      yy_cp = (yy_last_accepting_cpos);
      yy_current_state = (yy_last_accepting_state);

    yy_find_action:
      yy_act = yy_accept[yy_current_state];

      YY_DO_BEFORE_ACTION;

    do_action: /* This label is used only to access EOF actions. */

      switch (yy_act) { /* beginning of action switch */
      case 0:           /* must back up */
        /* undo the effects of YY_DO_BEFORE_ACTION */
        *yy_cp = (yy_hold_char);
        yy_cp = (yy_last_accepting_cpos);
        yy_current_state = (yy_last_accepting_state);
        goto yy_find_action;

      case 1:
        YY_RULE_SETUP
#line 131 "pplex.l"
        {
          ppecho(" ");
        }
        YY_BREAK
      case 2:
        YY_RULE_SETUP
#line 135 "pplex.l"
        {
          identification_division_line_number = cb_source_line;
          ppecho("IDENTIFICATION DIVISION.");
        }
        YY_BREAK
      case 3:
        YY_RULE_SETUP
#line 139 "pplex.l"
        {
          ppecho("ID DIVISION.");
        }
        YY_BREAK
      case 4:
        YY_RULE_SETUP
#line 140 "pplex.l"
        {
          ppecho("FUNCTION DIVISION.");
        }
        YY_BREAK
      case 5:
        YY_RULE_SETUP
#line 141 "pplex.l"
        {
          ppecho(yytext);
          return PROGRAM_ID;
        }
        YY_BREAK
      case 6:
        YY_RULE_SETUP
#line 142 "pplex.l"
        {
          ppecho(yytext);
          return FUNCTION_ID;
        }
        YY_BREAK
      case 7:
        YY_RULE_SETUP
#line 143 "pplex.l"
        {
          ppecho("ENVIRONMENT DIVISION");
          return ENVIRONMENT_DIVISION;
        }
        YY_BREAK
      case 8:
        YY_RULE_SETUP
#line 144 "pplex.l"
        {
          position_in_source_code = POSITION_AFTER_WORKING_STORAGE;
          ppecho("DATA DIVISION");
          return DATA_DIVISION;
        }
        YY_BREAK
      case 9:
        YY_RULE_SETUP
#line 149 "pplex.l"
        {
          if (copy_stack->next == NULL) {
            procedure_division_line_number = cb_source_line;
            position_in_source_code = POSITION_AFTER_PROCEDURE_DIVISION;
          }
          ppecho("PROCEDURE DIVISION");
          return PROCEDURE_DIVISION;
        }
        YY_BREAK
      case 10:
        YY_RULE_SETUP
#line 157 "pplex.l"
        {
          ppecho("END PROGRAM");
          return END_PROGRAM;
        }
        YY_BREAK
      case 11:
        YY_RULE_SETUP
#line 158 "pplex.l"
        {
          ppecho("END FUNCTION");
          return END_FUNCTION;
        }
        YY_BREAK
      case 12:
#line 161 "pplex.l"
      case 13:
        YY_RULE_SETUP
#line 161 "pplex.l"
        {
          ppecho(" ");
          if (cb_source_format != CB_FORMAT_FIXED) {
            ppecho(yytext);
          }
        }
        YY_BREAK
      case 14:
        YY_RULE_SETUP
#line 168 "pplex.l"
        {
          BEGIN PROCESS_STATE;
        }
        YY_BREAK

      case 15:
        /* rule 15 can match eol */
        YY_RULE_SETUP
#line 171 "pplex.l"
        {
          BEGIN INITIAL;
          unput('\n');
        }
        YY_BREAK
      case 16:
        YY_RULE_SETUP
#line 172 "pplex.l"
        {
          cb_warning(_("PROCESS statement is ignored"));
        }
        YY_BREAK

      case 17:
        YY_RULE_SETUP
#line 175 "pplex.l"
        {
          BEGIN COPY_STATE;
          return COPY;
        }
        YY_BREAK
      case 18:
        YY_RULE_SETUP
#line 176 "pplex.l"
        {
          BEGIN COPY_STATE;
          return COPY;
        }
        YY_BREAK
      case 19:
        YY_RULE_SETUP
#line 177 "pplex.l"
        {
          BEGIN COPY_STATE;
          return REPLACE;
        }
        YY_BREAK

      case 20:
        /* rule 20 can match eol */
        YY_RULE_SETUP
#line 180 "pplex.l"
        {
          ECHO;
          cb_source_line++;
        }
        YY_BREAK
      case 21:
        YY_RULE_SETUP
#line 181 "pplex.l"
        { /* ignore */
        }
        YY_BREAK
      case 22:
        YY_RULE_SETUP
#line 182 "pplex.l"
        {
          BEGIN INITIAL;
          return '.';
        }
        YY_BREAK
      case 23:
        YY_RULE_SETUP
#line 183 "pplex.l"
        {
          BEGIN PSEUDO_STATE;
          return EQEQ;
        }
        YY_BREAK
      case 24:
        YY_RULE_SETUP
#line 184 "pplex.l"
        {
          return '(';
        }
        YY_BREAK
      case 25:
        YY_RULE_SETUP
#line 185 "pplex.l"
        {
          return ')';
        }
        YY_BREAK
      case 26:
        YY_RULE_SETUP
#line 186 "pplex.l"
        {
          return BY;
        }
        YY_BREAK
      case 27:
        YY_RULE_SETUP
#line 187 "pplex.l"
        {
          return IN;
        }
        YY_BREAK
      case 28:
        YY_RULE_SETUP
#line 188 "pplex.l"
        {
          return OF;
        }
        YY_BREAK
      case 29:
        YY_RULE_SETUP
#line 189 "pplex.l"
        {
          return OFF;
        }
        YY_BREAK
      case 30:
        YY_RULE_SETUP
#line 190 "pplex.l"
        {
          return SUPPRESS;
        }
        YY_BREAK
      case 31:
        YY_RULE_SETUP
#line 191 "pplex.l"
        {
          return PRINTING;
        }
        YY_BREAK
      case 32:
        YY_RULE_SETUP
#line 192 "pplex.l"
        {
          return REPLACING;
        }
        YY_BREAK
      case 33:
        YY_RULE_SETUP
#line 193 "pplex.l"
        {
          return LEADING;
        }
        YY_BREAK
      case 34:
        YY_RULE_SETUP
#line 194 "pplex.l"
        {
          return TRAILING;
        }
        YY_BREAK
      case 35:
        YY_RULE_SETUP
#line 195 "pplex.l"
        {
          return JOINING;
        }
        YY_BREAK
      case 36:
        YY_RULE_SETUP
#line 196 "pplex.l"
        {
          return AS;
        }
        YY_BREAK
      case 37:
        YY_RULE_SETUP
#line 197 "pplex.l"
        {
          return PREFIX;
        }
        YY_BREAK
      case 38:
        YY_RULE_SETUP
#line 198 "pplex.l"
        {
          return SUFFIX;
        }
        YY_BREAK
      case 39:
        YY_RULE_SETUP
#line 199 "pplex.l"
        {
          return PREFIXING;
        }
        YY_BREAK
      case 40:
        YY_RULE_SETUP
#line 200 "pplex.l"
        {
          return SUFFIXING;
        }
        YY_BREAK
      case 41:
        YY_RULE_SETUP
#line 201 "pplex.l"
        {
#ifdef I18N_UTF8
          convert_ucs_hyphen_minus(yytext);
#endif /*I18N_UTF8*/
          pplval.s = strdup(yytext);
          return TOKEN;
        }
        YY_BREAK
      case 42:
#line 207 "pplex.l"
      case 43:
#line 208 "pplex.l"
      case 44:
        YY_RULE_SETUP
#line 208 "pplex.l"
        {
          pplval.s = strdup(yytext);
          return TOKEN;
        }
        YY_BREAK

      case 45:
        /* rule 45 can match eol */
        YY_RULE_SETUP
#line 212 "pplex.l"
        {
          ECHO;
          cb_source_line++;
        }
        YY_BREAK
      case 46:
        YY_RULE_SETUP
#line 213 "pplex.l"
        {
          pplval.s = strdup(" ");
          return TOKEN;
        }
        YY_BREAK
      case 47:
        YY_RULE_SETUP
#line 214 "pplex.l"
        {
          BEGIN COPY_STATE;
          return EQEQ;
        }
        YY_BREAK
      case 48:
        YY_RULE_SETUP
#line 215 "pplex.l"
        {
#ifdef I18N_UTF8
          convert_ucs_hyphen_minus(yytext);
#endif /*I18N_UTF8*/
          pplval.s = strdup(yytext);
          return TOKEN;
        }
        YY_BREAK
      case 49:
#line 221 "pplex.l"
      case 50:
#line 222 "pplex.l"
      case 51:
        YY_RULE_SETUP
#line 222 "pplex.l"
        {
          pplval.s = strdup(yytext);
          return TOKEN;
        }
        YY_BREAK

      case 52:
        YY_RULE_SETUP
#line 226 "pplex.l"
        {
          suppress_echo = 0;
          BEGIN COPY_STATE;
          return COPY;
        }
        YY_BREAK
      case 53:
        YY_RULE_SETUP
#line 227 "pplex.l"
        {
          suppress_echo = 0;
          BEGIN COPY_STATE;
          return COPY;
        }
        YY_BREAK
      case 54:
        YY_RULE_SETUP
#line 228 "pplex.l"
        {
          suppress_echo = 0;
          BEGIN COPY_STATE;
          return REPLACE;
        }
        YY_BREAK
      case 55:
        /* rule 55 can match eol */
        YY_RULE_SETUP
#line 229 "pplex.l"
        {
          ECHO;
          cb_source_line++;
        }
        YY_BREAK
      case 56:
        YY_RULE_SETUP
#line 230 "pplex.l"
        {
          ppecho(" ");
        }
        YY_BREAK
      case 57:
        YY_RULE_SETUP
#line 231 "pplex.l"
        {
          BEGIN INITIAL;
          if (!strcasecmp(yytext, "FILLER")) {
            ppecho(yytext);
          } else {
            ppecho_dataname(yytext);
          }
          suppress_echo = 0;
          if (cb_cobol68_copy_in_data_description) {
            pplval.s = strdup(yytext);
            return TOKEN;
          }
        }
        YY_BREAK
      case 58:
#line 245 "pplex.l"
      case 59:
#line 246 "pplex.l"
      case 60:
        YY_RULE_SETUP
#line 246 "pplex.l"
        {
          suppress_echo = 0;
          BEGIN INITIAL;
          ppecho(yytext);
        }
        YY_BREAK

      case 61:
        YY_RULE_SETUP
#line 249 "pplex.l"
        {
          suppress_echo = (omit_data_redef_name) ? 1 : 0;
          ppecho(yytext);
          BEGIN DATANAME_JOIN_STATE;
          if (cb_cobol68_copy_in_data_description) {
            return REDEFINES;
          }
        }
        YY_BREAK
      case 62:
#line 259 "pplex.l"
      case 63:
#line 260 "pplex.l"
      case 64:
#line 261 "pplex.l"
      case 65:
#line 262 "pplex.l"
      case 66:
#line 263 "pplex.l"
      case 67:
#line 264 "pplex.l"
      case 68:
        YY_RULE_SETUP
#line 264 "pplex.l"
        {
          /* these words are treated as comments */
          if (cb_verify(cb_author_paragraph, yytext)) {
            /* skip comments until the end of line */
            int c;

            within_comment = 1;
            while ((c = input()) != EOF) {
              if (c == '\n') {
                break;
              }
            }
            unput(c);
          }
        }
        YY_BREAK
      case 69:
#line 281 "pplex.l"
      case 70:
#line 282 "pplex.l"
      case 71:
#line 283 "pplex.l"
      case 72:
        YY_RULE_SETUP
#line 283 "pplex.l"
        {
          /* these words are comments in IBM COBOL */
          if (cb_verify(cb_eject_statement, yytext)) {
            /* do nothing for now */
          } else {
            /* ECHO; */ /* comment should be suppressed, shouldn't it? */
          }
        }
        YY_BREAK
      case 73:
        /* rule 73 can match eol */
        YY_RULE_SETUP
#line 292 "pplex.l"
        {
          ppecho("\n");
          cb_source_line++;
        }
        YY_BREAK
      case 74:
        YY_RULE_SETUP
#line 294 "pplex.l"
        {
          ppecho(" ");
        }
        YY_BREAK
      case 75:
        YY_RULE_SETUP
#line 296 "pplex.l"
        {
          if (inside_bracket) {
            ppecho(", ");
          } else {
            ppecho(" ");
          }
        }
        YY_BREAK
      case 76:
        YY_RULE_SETUP
#line 304 "pplex.l"
        {
          inside_bracket++;
          ppecho("(");
        }
        YY_BREAK
      case 77:
        YY_RULE_SETUP
#line 309 "pplex.l"
        {
          if (inside_bracket) {
            inside_bracket--;
          }
          ppecho(")");
        }
        YY_BREAK
      case 78:
/* rule 78 can match eol */
#line 317 "pplex.l"
      case 79:
/* rule 79 can match eol */
#line 318 "pplex.l"
      case 80:
/* rule 80 can match eol */
#line 319 "pplex.l"
      case 81:
/* rule 81 can match eol */
#line 320 "pplex.l"
      case 82:
/* rule 82 can match eol */
#line 321 "pplex.l"
      case 83:
/* rule 83 can match eol */
#line 322 "pplex.l"
      case 84:
/* rule 84 can match eol */
#line 323 "pplex.l"
      case 85:
/* rule 85 can match eol */
#line 324 "pplex.l"
      case 86:
/* rule 86 can match eol */
#line 325 "pplex.l"
      case 87:
/* rule 87 can match eol */
#line 326 "pplex.l"
      case 88:
/* rule 88 can match eol */
#line 327 "pplex.l"
      case 89:
/* rule 89 can match eol */
#line 328 "pplex.l"
      case 90:
/* rule 90 can match eol */
#line 329 "pplex.l"
      case 91:
/* rule 91 can match eol */
#line 330 "pplex.l"
      case 92:
        /* rule 92 can match eol */
        YY_RULE_SETUP
#line 330 "pplex.l"
        {
          /* each numeric is not a level-number */
          char *p, *pcrnt;
          cobc_mbspc2ascii(yytext);
          pcrnt = yytext;
          while (*pcrnt) {
            for (p = pcrnt; *p && *p != ' ' && *p != '\n'; p++)
              ;
            for (; *p == ' ' || *p == '\n'; p++) {
              if (*p == '\n') {
                cb_source_line++;
              }
              *p = '\0';
            }
            ppecho(pcrnt);
            if (*p) {
              ppecho(" ");
            }
            pcrnt = p;
          }
        }
        YY_BREAK
      case 93:
        YY_RULE_SETUP
#line 352 "pplex.l"
        {
          char *p = yytext;
          cobc_mbspc2ascii(yytext);
          while (*p == ' ') {
            p++;
          }
          suppress_echo = (omit_data_entry_name) ? 1 : 0;
          ppecho(p);
          if (current_division == PP_DATA_DIVISION) {
            BEGIN DATANAME_JOIN_STATE;
            if (cb_cobol68_copy_in_data_description) {
              return LEVEL_NUMBER;
            }
          }
        }
        YY_BREAK
      case 94:
        YY_RULE_SETUP
#line 368 "pplex.l"
        {
          ppecho(yytext);
          return yytext[0];
        }
        YY_BREAK
      case 95:
        YY_RULE_SETUP
#line 373 "pplex.l"
        {
#ifdef I18N_UTF8
          convert_ucs_hyphen_minus(yytext);
#endif /*I18N_UTF8*/
          ppecho(yytext);
        }
        YY_BREAK
      case 96:
#line 379 "pplex.l"
      case 97:
#line 380 "pplex.l"
      case 98:
        YY_RULE_SETUP
#line 380 "pplex.l"
        {
          ppecho(yytext);
        }
        YY_BREAK
      case YY_STATE_EOF(INITIAL):
      case YY_STATE_EOF(PROCESS_STATE):
      case YY_STATE_EOF(COPY_STATE):
      case YY_STATE_EOF(PSEUDO_STATE):
      case YY_STATE_EOF(DATANAME_JOIN_STATE):
#line 382 "pplex.l"
      {
        struct copy_info *p;

        p = copy_stack;

        yy_delete_buffer(YY_CURRENT_BUFFER);

        /* Terminate at the end of all input */
        if (p->next == NULL) {
          within_comment = 0;
          newline_count = 0;
          inside_bracket = 0;
          current_replace_list = NULL;
          current_copy_replace_list = NULL;
          current_joining_ext = NULL;
          text_queue1 = text_queue2 = NULL;
          copy_stack = NULL;
          quotation_mark = 0;
          consecutive_quotation = 0;
          last_line_1 = -1;
          last_line_2 = -1;
          yyterminate();
        }

        /* Close the current file */
        fclose(ppin);

        /* Switch to the last buffer */
        if (p->replacing) {
          pp_set_copy_replace_list(NULL);
        }
        if (p->joining) {
          pp_set_joining_ext(NULL);
        }
        switch_to_buffer(p->line, p->file, p->buffer);
        quotation_mark = p->quotation_mark;

        copy_stack = p->next;
        free(p);
      }
        YY_BREAK
      case 99:
        YY_RULE_SETUP
#line 423 "pplex.l"
        YY_FATAL_ERROR("flex scanner jammed");
        YY_BREAK
#line 2722 "pplex.c"

      case YY_END_OF_BUFFER: {
        /* Amount of text matched not including the EOB char. */
        int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

        /* Undo the effects of YY_DO_BEFORE_ACTION. */
        *yy_cp = (yy_hold_char);
        YY_RESTORE_YY_MORE_OFFSET

        if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW) {
          /* We're scanning a new file or input source.  It's
           * possible that this happened because the user
           * just pointed yyin at a new source and called
           * yylex().  If so, then we have to assure
           * consistency between YY_CURRENT_BUFFER and our
           * globals.  Here is the right place to do so, because
           * this is the first action (other than possibly a
           * back-up) that will match for the new input source.
           */
          (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
          YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
          YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
        }

        /* Note that here we test for yy_c_buf_p "<=" to the position
         * of the first EOB in the buffer, since yy_c_buf_p will
         * already have been incremented past the NUL character
         * (since all states make transitions on EOB to the
         * end-of-buffer state).  Contrast this with the test
         * in input().
         */
        if ((yy_c_buf_p) <=
            &YY_CURRENT_BUFFER_LVALUE
                 ->yy_ch_buf[(yy_n_chars)]) { /* This was really a NUL. */
          yy_state_type yy_next_state;

          (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

          yy_current_state = yy_get_previous_state();

          /* Okay, we're now positioned to make the NUL
           * transition.  We couldn't have
           * yy_get_previous_state() go ahead and do it
           * for us because it doesn't know how to deal
           * with the possibility of jamming (and we don't
           * want to build jamming into it because then it
           * will run more slowly).
           */

          yy_next_state = yy_try_NUL_trans(yy_current_state);

          yy_bp = (yytext_ptr) + YY_MORE_ADJ;

          if (yy_next_state) {
            /* Consume the NUL. */
            yy_cp = ++(yy_c_buf_p);
            yy_current_state = yy_next_state;
            goto yy_match;
          }

          else {
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);
            goto yy_find_action;
          }
        }

        else
          switch (yy_get_next_buffer()) {
          case EOB_ACT_END_OF_FILE: {
            (yy_did_buffer_switch_on_eof) = 0;

            if (yywrap()) {
              /* Note: because we've taken care in
               * yy_get_next_buffer() to have set up
               * yytext, we can now set up
               * yy_c_buf_p so that if some total
               * hoser (like flex itself) wants to
               * call the scanner after we return the
               * YY_NULL, it'll still work - another
               * YY_NULL will get returned.
               */
              (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

              yy_act = YY_STATE_EOF(YY_START);
              goto do_action;
            }

            else {
              if (!(yy_did_buffer_switch_on_eof))
                YY_NEW_FILE;
            }
            break;
          }

          case EOB_ACT_CONTINUE_SCAN:
            (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

            yy_current_state = yy_get_previous_state();

            yy_cp = (yy_c_buf_p);
            yy_bp = (yytext_ptr) + YY_MORE_ADJ;
            goto yy_match;

          case EOB_ACT_LAST_MATCH:
            (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

            yy_current_state = yy_get_previous_state();

            yy_cp = (yy_c_buf_p);
            yy_bp = (yytext_ptr) + YY_MORE_ADJ;
            goto yy_find_action;
          }
        break;
      }

      default:
        YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
      } /* end of action switch */
    }   /* end of scanning one token */
  }     /* end of user's declarations */
} /* end of yylex */

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
static int yy_get_next_buffer(void) {
  char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
  char *source = (yytext_ptr);
  int number_to_move, i;
  int ret_val;

  if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
    YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

  if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer ==
      0) { /* Don't try to fill the buffer, so this is an EOF. */
    if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1) {
      /* We matched a single character, the EOB, so
       * treat this as a final EOF.
       */
      return EOB_ACT_END_OF_FILE;
    }

    else {
      /* We matched some text prior to the EOB, first
       * process it.
       */
      return EOB_ACT_LAST_MATCH;
    }
  }

  /* Try to read more data. */

  /* First move last chars to start of buffer. */
  number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

  for (i = 0; i < number_to_move; ++i)
    *(dest++) = *(source++);

  if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
    /* don't do the read, it's not guaranteed to return an EOF,
     * just force an EOF
     */
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

  else {
    int num_to_read =
        YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

    while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */

      /* just a shorter name for the current buffer */
      YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

      int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

      if (b->yy_is_our_buffer) {
        int new_size = b->yy_buf_size * 2;

        if (new_size <= 0)
          b->yy_buf_size += b->yy_buf_size / 8;
        else
          b->yy_buf_size *= 2;

        b->yy_ch_buf = (char *)
            /* Include room in for 2 EOB chars. */
            yyrealloc((void *)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2));
      } else
        /* Can't grow it, we don't own it. */
        b->yy_ch_buf = NULL;

      if (!b->yy_ch_buf)
        YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

      (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

      num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
    }

    if (num_to_read > YY_READ_BUF_SIZE)
      num_to_read = YY_READ_BUF_SIZE;

    /* Read in more data. */
    YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
             (yy_n_chars), num_to_read);

    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  if ((yy_n_chars) == 0) {
    if (number_to_move == YY_MORE_ADJ) {
      ret_val = EOB_ACT_END_OF_FILE;
      yyrestart(yyin);
    }

    else {
      ret_val = EOB_ACT_LAST_MATCH;
      YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
    /* Extend the array by 50%, plus the number we really need. */
    int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *)yyrealloc(
        (void *)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
    if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
    /* "- 2" to take care of EOB's */
    YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
  }

  (yy_n_chars) += number_to_move;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
  YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

  (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

  return ret_val;
}

/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state(void) {
  yy_state_type yy_current_state;
  char *yy_cp;

  yy_current_state = (yy_start);
  yy_current_state += YY_AT_BOL();

  for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp) {
    YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
    if (yy_accept[yy_current_state]) {
      (yy_last_accepting_state) = yy_current_state;
      (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
      yy_current_state = (int)yy_def[yy_current_state];
      if (yy_current_state >= 609)
        yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  }

  return yy_current_state;
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state) {
  int yy_is_jam;
  char *yy_cp = (yy_c_buf_p);

  YY_CHAR yy_c = 1;
  if (yy_accept[yy_current_state]) {
    (yy_last_accepting_state) = yy_current_state;
    (yy_last_accepting_cpos) = yy_cp;
  }
  while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
    yy_current_state = (int)yy_def[yy_current_state];
    if (yy_current_state >= 609)
      yy_c = yy_meta[yy_c];
  }
  yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
  yy_is_jam = (yy_current_state == 608);

  return yy_is_jam ? 0 : yy_current_state;
}

#ifndef YY_NO_UNPUT

static void yyunput(int c, char *yy_bp) {
  char *yy_cp;

  yy_cp = (yy_c_buf_p);

  /* undo effects of setting up yytext */
  *yy_cp = (yy_hold_char);

  if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf +
                  2) { /* need to shift things up to make room */
    /* +2 for EOB chars. */
    int number_to_move = (yy_n_chars) + 2;
    char *dest = &YY_CURRENT_BUFFER_LVALUE
                      ->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
    char *source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

    while (source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
      *--dest = *--source;

    yy_cp += (int)(dest - source);
    yy_bp += (int)(dest - source);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) =
        (int)YY_CURRENT_BUFFER_LVALUE->yy_buf_size;

    if (yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2)
      YY_FATAL_ERROR("flex scanner push-back overflow");
  }

  *--yy_cp = (char)c;

  (yytext_ptr) = yy_bp;
  (yy_hold_char) = *yy_cp;
  (yy_c_buf_p) = yy_cp;
}

#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

{
  int c;

  *(yy_c_buf_p) = (yy_hold_char);

  if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
    /* yy_c_buf_p now points to the character we want to return.
     * If this occurs *before* the EOB characters, then it's a
     * valid NUL; if not, then we've hit the end of the buffer.
     */
    if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
      /* This was really a NUL. */
      *(yy_c_buf_p) = '\0';

    else { /* need more input */
      int offset = (int)((yy_c_buf_p) - (yytext_ptr));
      ++(yy_c_buf_p);

      switch (yy_get_next_buffer()) {
      case EOB_ACT_LAST_MATCH:
        /* This happens because yy_g_n_b()
         * sees that we've accumulated a
         * token and flags that we need to
         * try matching the token before
         * proceeding.  But for input(),
         * there's no matching to consider.
         * So convert the EOB_ACT_LAST_MATCH
         * to EOB_ACT_END_OF_FILE.
         */

        /* Reset buffer status. */
        yyrestart(yyin);

        /*FALLTHROUGH*/

      case EOB_ACT_END_OF_FILE: {
        if (yywrap())
          return 0;

        if (!(yy_did_buffer_switch_on_eof))
          YY_NEW_FILE;
#ifdef __cplusplus
        return yyinput();
#else
        return input();
#endif
      }

      case EOB_ACT_CONTINUE_SCAN:
        (yy_c_buf_p) = (yytext_ptr) + offset;
        break;
      }
    }
  }

  c = *(unsigned char *)(yy_c_buf_p); /* cast for 8-bit char's */
  *(yy_c_buf_p) = '\0';               /* preserve yytext */
  (yy_hold_char) = *++(yy_c_buf_p);

  YY_CURRENT_BUFFER_LVALUE->yy_at_bol = (c == '\n');

  return c;
}
#endif /* ifndef YY_NO_INPUT */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
void yyrestart(FILE *input_file) {

  if (!YY_CURRENT_BUFFER) {
    yyensure_buffer_stack();
    YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
  }

  yy_init_buffer(YY_CURRENT_BUFFER, input_file);
  yy_load_buffer_state();
}

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer) {

  /* TODO. We should be able to replace this entire function body
   * with
   *		yypop_buffer_state();
   *		yypush_buffer_state(new_buffer);
   */
  yyensure_buffer_stack();
  if (YY_CURRENT_BUFFER == new_buffer)
    return;

  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  YY_CURRENT_BUFFER_LVALUE = new_buffer;
  yy_load_buffer_state();

  /* We don't actually know whether we did this switch during
   * EOF (yywrap()) processing, but the only time this flag
   * is looked at is after yywrap() is called, so it's safe
   * to go ahead and always set it.
   */
  (yy_did_buffer_switch_on_eof) = 1;
}

static void yy_load_buffer_state(void) {
  (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
  (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
  yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
  (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c
 * YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size) {
  YY_BUFFER_STATE b;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_buf_size = size;

  /* yy_ch_buf has to be 2 characters longer than the size given because
   * we need to put in 2 end-of-buffer characters.
   */
  b->yy_ch_buf = (char *)yyalloc((yy_size_t)(b->yy_buf_size + 2));
  if (!b->yy_ch_buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

  b->yy_is_our_buffer = 1;

  yy_init_buffer(b, file);

  return b;
}

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
void yy_delete_buffer(YY_BUFFER_STATE b) {

  if (!b)
    return;

  if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
    YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

  if (b->yy_is_our_buffer)
    yyfree((void *)b->yy_ch_buf);

  yyfree((void *)b);
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE *file)

{
  int oerrno = errno;

  yy_flush_buffer(b);

  b->yy_input_file = file;
  b->yy_fill_buffer = 1;

  /* If b is the current buffer, then yy_init_buffer was _probably_
   * called from yyrestart() or through yy_get_next_buffer.
   * In that case, we don't want to reset the lineno or column.
   */
  if (b != YY_CURRENT_BUFFER) {
    b->yy_bs_lineno = 1;
    b->yy_bs_column = 0;
  }

  b->yy_is_interactive = 0;

  errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
void yy_flush_buffer(YY_BUFFER_STATE b) {
  if (!b)
    return;

  b->yy_n_chars = 0;

  /* We always need two end-of-buffer characters.  The first causes
   * a transition to the end-of-buffer state.  The second causes
   * a jam in that state.
   */
  b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
  b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

  b->yy_buf_pos = &b->yy_ch_buf[0];

  b->yy_at_bol = 1;
  b->yy_buffer_status = YY_BUFFER_NEW;

  if (b == YY_CURRENT_BUFFER)
    yy_load_buffer_state();
}

/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer) {
  if (new_buffer == NULL)
    return;

  yyensure_buffer_stack();

  /* This block is copied from yy_switch_to_buffer. */
  if (YY_CURRENT_BUFFER) {
    /* Flush out information for old buffer. */
    *(yy_c_buf_p) = (yy_hold_char);
    YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
    YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
  }

  /* Only push if top exists. Otherwise, replace top. */
  if (YY_CURRENT_BUFFER)
    (yy_buffer_stack_top)++;
  YY_CURRENT_BUFFER_LVALUE = new_buffer;

  /* copied from yy_switch_to_buffer. */
  yy_load_buffer_state();
  (yy_did_buffer_switch_on_eof) = 1;
}

/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
void yypop_buffer_state(void) {
  if (!YY_CURRENT_BUFFER)
    return;

  yy_delete_buffer(YY_CURRENT_BUFFER);
  YY_CURRENT_BUFFER_LVALUE = NULL;
  if ((yy_buffer_stack_top) > 0)
    --(yy_buffer_stack_top);

  if (YY_CURRENT_BUFFER) {
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
  }
}

/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
static void yyensure_buffer_stack(void) {
  yy_size_t num_to_alloc;

  if (!(yy_buffer_stack)) {

    /* First allocation is just for 2 elements, since we don't know if this
     * scanner will even need a stack. We use 2 instead of 1 to avoid an
     * immediate realloc on the next call.
     */
    num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
    (yy_buffer_stack) = (struct yy_buffer_state **)yyalloc(
        num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    memset((yy_buffer_stack), 0,
           num_to_alloc * sizeof(struct yy_buffer_state *));

    (yy_buffer_stack_max) = num_to_alloc;
    (yy_buffer_stack_top) = 0;
    return;
  }

  if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {

    /* Increase the buffer to prepare for a possible push. */
    yy_size_t grow_size = 8 /* arbitrary grow size */;

    num_to_alloc = (yy_buffer_stack_max) + grow_size;
    (yy_buffer_stack) = (struct yy_buffer_state **)yyrealloc(
        (yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state *));
    if (!(yy_buffer_stack))
      YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

    /* zero only the new slots.*/
    memset((yy_buffer_stack) + (yy_buffer_stack_max), 0,
           grow_size * sizeof(struct yy_buffer_state *));
    (yy_buffer_stack_max) = num_to_alloc;
  }
}

/** Setup the input buffer state to scan directly from a user-specified
 * character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char *base, yy_size_t size) {
  YY_BUFFER_STATE b;

  if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR ||
      base[size - 1] != YY_END_OF_BUFFER_CHAR)
    /* They forgot to leave room for the EOB's. */
    return NULL;

  b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
  if (!b)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

  b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
  b->yy_buf_pos = b->yy_ch_buf = base;
  b->yy_is_our_buffer = 0;
  b->yy_input_file = NULL;
  b->yy_n_chars = b->yy_buf_size;
  b->yy_is_interactive = 0;
  b->yy_at_bol = 1;
  b->yy_fill_buffer = 0;
  b->yy_buffer_status = YY_BUFFER_NEW;

  yy_switch_to_buffer(b);

  return b;
}

/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char *yystr) {

  return yy_scan_bytes(yystr, (int)strlen(yystr));
}

/** Setup the input buffer state to scan the given bytes. The next call to
 * yylex() will scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char *yybytes, int _yybytes_len) {
  YY_BUFFER_STATE b;
  char *buf;
  yy_size_t n;
  int i;

  /* Get memory for full buffer, including space for trailing EOB's. */
  n = (yy_size_t)(_yybytes_len + 2);
  buf = (char *)yyalloc(n);
  if (!buf)
    YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

  for (i = 0; i < _yybytes_len; ++i)
    buf[i] = yybytes[i];

  buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

  b = yy_scan_buffer(buf, n);
  if (!b)
    YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

  /* It's okay to grow etc. this buffer, and we should throw it
   * away when we're done.
   */
  b->yy_is_our_buffer = 1;

  return b;
}

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

static void yynoreturn yy_fatal_error(const char *msg) {
  fprintf(stderr, "%s\n", msg);
  exit(YY_EXIT_FAILURE);
}

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                              \
  do {                                                                         \
    /* Undo effects of setting up yytext. */                                   \
    int yyless_macro_arg = (n);                                                \
    YY_LESS_LINENO(yyless_macro_arg);                                          \
    yytext[yyleng] = (yy_hold_char);                                           \
    (yy_c_buf_p) = yytext + yyless_macro_arg;                                  \
    (yy_hold_char) = *(yy_c_buf_p);                                            \
    *(yy_c_buf_p) = '\0';                                                      \
    yyleng = yyless_macro_arg;                                                 \
  } while (0)

/* Accessor  methods (get/set functions) to struct members. */

/** Get the current line number.
 *
 */
int yyget_lineno(void) { return yylineno; }

/** Get the input stream.
 *
 */
FILE *yyget_in(void) { return yyin; }

/** Get the output stream.
 *
 */
FILE *yyget_out(void) { return yyout; }

/** Get the length of the current token.
 *
 */
int yyget_leng(void) { return yyleng; }

/** Get the current token.
 *
 */

char *yyget_text(void) { return yytext; }

/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number) { yylineno = _line_number; }

/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE *_in_str) { yyin = _in_str; }

void yyset_out(FILE *_out_str) { yyout = _out_str; }

int yyget_debug(void) { return yy_flex_debug; }

void yyset_debug(int _bdebug) { yy_flex_debug = _bdebug; }

static int yy_init_globals(void) {
  /* Initialization is the same as for the non-reentrant scanner.
   * This function is called from yylex_destroy(), so don't allocate here.
   */

  (yy_buffer_stack) = NULL;
  (yy_buffer_stack_top) = 0;
  (yy_buffer_stack_max) = 0;
  (yy_c_buf_p) = NULL;
  (yy_init) = 0;
  (yy_start) = 0;

/* Defined in main.c */
#ifdef YY_STDINIT
  yyin = stdin;
  yyout = stdout;
#else
  yyin = NULL;
  yyout = NULL;
#endif

  /* For future reference: Set errno on error, since we are called by
   * yylex_init()
   */
  return 0;
}

/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void) {

  /* Pop the buffer stack, destroying each element. */
  while (YY_CURRENT_BUFFER) {
    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    yypop_buffer_state();
  }

  /* Destroy the stack itself. */
  yyfree((yy_buffer_stack));
  (yy_buffer_stack) = NULL;

  /* Reset the globals. This is important in a non-reentrant scanner so the next
   * time yylex() is called, initialization will occur. */
  yy_init_globals();

  return 0;
}

/*
 * Internal utility routines.
 */

#ifndef yytext_ptr
static void yy_flex_strncpy(char *s1, const char *s2, int n) {

  int i;
  for (i = 0; i < n; ++i)
    s1[i] = s2[i];
}
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char *s) {
  int n;
  for (n = 0; s[n]; ++n)
    ;

  return n;
}
#endif

void *yyalloc(yy_size_t size) { return malloc(size); }

void *yyrealloc(void *ptr, yy_size_t size) {

  /* The cast to (char *) in the following accommodates both
   * implementations that use char* generic pointers, and those
   * that use void* generic pointers.  It works with the latter
   * because both ANSI C and C++ allow castless assignment from
   * any pointer type to void*, and deal with argument conversions
   * as though doing an assignment.
   */
  return realloc(ptr, size);
}

void yyfree(void *ptr) {
  free((char *)ptr); /* see yyrealloc() for (char *) cast */
}

#define YYTABLES_NAME "yytables"

#line 423 "pplex.l"

void pp_set_replace_list(struct cb_replace_list *list) {
  current_replace_list = list;
}

void pp_set_copy_replace_list(struct cb_replace_list *list) {
  current_copy_replace_list = list;
}

void pp_set_joining_ext(struct cb_joining_ext *ext) {
  current_joining_ext = ext;
}

#ifdef I18N_UTF8
#define UTF8_FULLWIDTH_HYPHEN_MINUS "\xEF\xBC\x8D"
#define UTF8_MINUS_SIGN "\xE2\x88\x92"
#else /*!I18N_UTF8*/
#define SJIS_MINUS_SIGN "\x81\x7c"
#endif /*I18N_UTF8*/

#ifdef I18N_UTF8
static void convert_ucs_hyphen_minus(char *namebuf) {
  char *p = namebuf;
  while (NULL != (p = strstr(p, UTF8_MINUS_SIGN))) {
    memcpy(p, UTF8_FULLWIDTH_HYPHEN_MINUS, 3);
    p += 3;
  }
  return;
}
#endif /*I18N_UTF8*/

static void ppecho_dataname(char *namebuf) {
  int extlen, namelen, seplen;
  const char *ext;
  const char *sep;

#ifdef I18N_UTF8
  convert_ucs_hyphen_minus(namebuf);
#endif /*I18N_UTF8*/
  if (!current_joining_ext) {
    ppecho(namebuf);
  } else {
    ext = current_joining_ext->ext;
    if (!plexbuff1) {
      plexbuff1 = cobc_malloc(COB_SMALL_BUFF);
    }
    extlen = strlen(ext);
    namelen = strlen(namebuf);
#ifdef I18N_UTF8
    if (!utf8_ext_pick((unsigned char *)ext)) {
      sep = "-";
      seplen = 1;
    } else {
      sep = UTF8_FULLWIDTH_HYPHEN_MINUS;
      seplen = 3;
    }
#else  /*!I18N_UTF8*/
    if (!sjis_pick((unsigned char *)ext)) {
      sep = "-";
      seplen = 1;
    } else {
      sep = SJIS_MINUS_SIGN;
      seplen = 2;
    }
#endif /*I18N_UTF8*/
    if (current_joining_ext->type == joining_as_prefix) {
      memcpy(plexbuff1, ext, extlen);
      memcpy(&(plexbuff1[extlen]), sep, seplen);
      memcpy(&(plexbuff1[extlen + seplen]), &(namebuf[0]), namelen + 1);
    } else if (current_joining_ext->type == joining_as_suffix) {
      memcpy(plexbuff1, &(namebuf[0]), namelen);
      memcpy(&(plexbuff1[namelen]), sep, seplen);
      memcpy(&(plexbuff1[namelen + seplen]), ext, extlen + 1);
    } else if (current_joining_ext->type == prefixing) {
      memcpy(plexbuff1, ext, extlen);
      memcpy(&(plexbuff1[extlen]), &(namebuf[0]), namelen + 1);
    } else if (current_joining_ext->type == suffixing) {
      memcpy(plexbuff1, &(namebuf[0]), namelen);
      memcpy(&(plexbuff1[namelen]), ext, extlen + 1);
    }
    ppecho(plexbuff1);
  }
}

static void switch_to_buffer(const int line, const char *file,
                             YY_BUFFER_STATE buffer) {
  char *p;

  cb_source_line = line;
  cb_source_file = strdup(file);
  for (p = cb_source_file; *p; p++) {
    if (*p == '\\') {
      *p = '/';
    }
  }
  yy_switch_to_buffer(buffer);
  fprintf(yyout, "# %d \"%s\"\n", line, cb_source_file);
}

int ppopen(const char *name, struct cb_joining_ext *joining_ext,
           struct cb_replace_list *replace_list) {
  struct copy_info *p;

  for (; newline_count > 0; newline_count--) {
    ungetc('\n', ppin);
  }

  /* Open the copy file */
  ppin = fopen(name, "rb");
  if (!ppin) {
    if (cb_source_file) {
      cb_error(_("%s: %s"), name, strerror(errno));
    } else {
      perror(name);
    }
    return -1;
  }

  /* Add to dependency list */
  if (cb_depend_file) {
    cb_depend_list = cb_text_list_add(cb_depend_list, name);
  }

  /* Preserve the current buffer */
  p = cobc_malloc(sizeof(struct copy_info));
  p->line = cb_source_line;
  p->file = cb_source_file;
  p->replacing = replace_list ? 1 : 0;
  p->joining = joining_ext ? 1 : 0;
  p->buffer = YY_CURRENT_BUFFER;
  p->quotation_mark = quotation_mark;
  p->next = copy_stack;
  copy_stack = p;

  /* Switch to new buffer */
  if (replace_list) {
    pp_set_copy_replace_list(replace_list);
  }
  if (joining_ext) {
    pp_set_joining_ext(joining_ext);
  }
  switch_to_buffer(1, name, yy_create_buffer(ppin, YY_BUF_SIZE));
  return 0;
}

int ppcopy(const char *name, const char *lib,
           struct cb_joining_ext *joining_ext,
           struct cb_replace_list *replace_list) {
  struct cb_text_list *il;
  struct cb_text_list *el;
  char *s;
  struct stat st;

  if (lib) {
    if (!plexbuff1) {
      plexbuff1 = cobc_malloc(COB_SMALL_BUFF);
    }
    snprintf(plexbuff1, COB_SMALL_MAX, "%s/%s", lib, name);
    s = plexbuff1;
  } else {
    s = (char *)name;
  }

  /* Find the file */
  if (stat(s, &st) == 0) {
    return ppopen(s, joining_ext, replace_list);
  }
  if (!plexbuff2) {
    plexbuff2 = cobc_malloc(COB_SMALL_BUFF);
  }
  for (el = cb_extension_list; el; el = el->next) {
    snprintf(plexbuff2, COB_SMALL_MAX, "%s%s", s, el->text);
    if (stat(plexbuff2, &st) == 0) {
      return ppopen(plexbuff2, joining_ext, replace_list);
    }
  }
  if (*s != '/') {
    for (il = cb_include_list; il; il = il->next) {
      for (el = cb_extension_list; el; el = el->next) {
        snprintf(plexbuff2, COB_SMALL_MAX, "%s/%s%s", il->text, name, el->text);
        if (stat(plexbuff2, &st) == 0) {
          return ppopen(plexbuff2, joining_ext, replace_list);
        }
      }
    }
  }
  cb_error(_("%s: %s"), name, strerror(errno));
  return -1;
}

/* Check directives */
/* This is horrible but we have to parse directives directly after the read */
/* as flex buffers up input and it is then too late to use the flex parser */

static void check_directive(char *buff, int *line_size) {
  char *s;
  char *dirptr;
  size_t cnt;
  int n;
  char sbuff[5][256];

  if (cb_source_format == CB_FORMAT_FIXED) {
    if (*line_size < 8) {
      return;
    }
    if (buff[6] != ' ') {
      return;
    }
    s = &buff[7];
  } else {
    s = buff;
  }
  for (; *s == ' '; s++) {
    ;
  }
  dirptr = s;
  if (*s != '>') {
    return;
  }
  s++;
  if (*s != '>') {
    return;
  }
  s++;
  if (*s == 'D') {
    if (cb_flag_debugging_line) {
      memset(dirptr, ' ', 3);
    } else {
      for (cnt = 0; cnt < newline_count; cnt++) {
        buff[cnt] = '\n';
      }
      buff[cnt] = 0;
      strcat(buff, "      *> DEBUG\n");
      *line_size = strlen(buff);
      newline_count = 0;
    }
    return;
  }
  memset(sbuff[0], 0, sizeof(sbuff));
  n = sscanf(s, "%255s %255s %255s %255s %255s", sbuff[0], sbuff[1], sbuff[2],
             sbuff[3], sbuff[4]);
  for (cnt = 0; cnt < newline_count; cnt++) {
    buff[cnt] = '\n';
  }
  buff[cnt] = 0;
  newline_count = 0;
  strcat(buff, "      *> DIRECTIVE\n");
  *line_size = strlen(buff);
  if (n < 2 || strcasecmp(sbuff[0], "SOURCE")) {
    cb_warning(_("Invalid directive - ignored"));
    return;
  }
  switch (n) {
  case 2:
    if (!strcasecmp(sbuff[1], "FIXED")) {
      cb_source_format = CB_FORMAT_FIXED;
      return;
    }
    if (!strcasecmp(sbuff[1], "FREE")) {
      cb_source_format = CB_FORMAT_FREE;
      return;
    }
    if (!strcasecmp(sbuff[1], "FREE_1COL_ASTER")) {
      cb_source_format = CB_FORMAT_FREE_1COL_ASTER;
      cb_source_format1 = 1;
      return;
    }
    break;
  case 3:
    if (strcasecmp(sbuff[1], "FORMAT") && strcasecmp(sbuff[1], "IS")) {
      break;
    }
    if (!strcasecmp(sbuff[2], "FIXED")) {
      cb_source_format = CB_FORMAT_FIXED;
      return;
    }
    if (!strcasecmp(sbuff[2], "FREE")) {
      cb_source_format = CB_FORMAT_FREE;
      return;
    }
    if (!strcasecmp(sbuff[2], "FREE_1COL_ASTER")) {
      cb_source_format = CB_FORMAT_FREE_1COL_ASTER;
      cb_source_format1 = 1;
      return;
    }
    if (!strcasecmp(sbuff[2], "VARIABLE")) {
      cb_source_format = CB_FORMAT_VARIABLE;
    }
    break;
  default:
    if (strcasecmp(sbuff[1], "FORMAT")) {
      break;
    }
    if (strcasecmp(sbuff[2], "IS")) {
      break;
    }
    if (!strcasecmp(sbuff[3], "FIXED")) {
      cb_source_format = CB_FORMAT_FIXED;
      return;
    }
    if (!strcasecmp(sbuff[3], "FREE")) {
      cb_source_format = CB_FORMAT_FREE;
      return;
    }
    if (!strcasecmp(sbuff[3], "FREE_1COL_ASTER")) {
      cb_source_format = CB_FORMAT_FREE_1COL_ASTER;
      cb_source_format1 = 1;
      return;
    }
    if (!strcasecmp(sbuff[3], "VARIABLE")) {
      cb_source_format = CB_FORMAT_VARIABLE;
    }
    break;
  }
  cb_warning(_("Invalid directive - ignored"));
}

static void check_dollar_directive(char *buff, int *line_size) {
  struct cb_constant_list *l;
  char *s;
  size_t cnt;
  int n;
  char sbuff[5][256];
  int isDEFINED, isNOT;
  int i;
  COB_UNUSED(n);

  if (cb_source_format == CB_FORMAT_FIXED) {
    if (*line_size < 8) {
      return;
    }
    if (buff[6] != '$') {
      return;
    }
    if (*line_size > cb_text_column + 1) {
      strcpy(buff + cb_text_column, "\n");
    }
    s = &buff[6];
  } else {
    if (buff[1] != '$') {
      return;
    }
    s = buff;
  }

  memset(sbuff[0], 0, sizeof(sbuff));
  n = sscanf(s, "%255s %255s %255s %255s %255s", sbuff[0], sbuff[1], sbuff[2],
             sbuff[3], sbuff[4]);
  for (cnt = 0; cnt < newline_count; cnt++) {
    buff[cnt] = '\n';
  }
  buff[cnt] = 0;
  newline_count = 0;
  strcat(buff, "      *> DIRECTIVE\n");
  *line_size = strlen(buff);

  if (strcasecmp(sbuff[0], "$IF") == 0) {
    compile_directive_depth++;
    if (compile_directive_depth >= MAX_DEPTH) {
      compile_directive_depth = -1;
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("$IF is nested more than 10 times"));
      return;
    }
    if (compile_directive_depth < 0) {
      compile_directive_depth = -1;
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("Fatal error in $IF statement"));
      return;
    }
    if (strlen(sbuff[1]) <= 0) {
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("Arguments not enough to $IF statemen"));
      return;
    }

    isDEFINED = 0;
    isNOT = 0;
    cb_compile_status_list[compile_directive_depth] = CB_COMPILE_STATUS_FALSE;
    if (strcasecmp(sbuff[2], "NOT") == 0) {
      isNOT = 1;
      cb_compile_status_list[compile_directive_depth] = CB_COMPILE_STATUS_TRUE;
    }
    if (strcasecmp(sbuff[2 + isNOT], "DEFINED") == 0) {
      isDEFINED = 1;
    } else if (strcasecmp(sbuff[2 + isNOT], "=") != 0 ||
               strlen(sbuff[3 + isNOT]) <= 0) {
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("Invalid argument $IF statemen"));
      return;
    }
    l = cb_const_list;
    while (l) {
      if (strcasecmp(l->name, sbuff[1]) == 0) {
        if (isDEFINED) {
          if (isNOT)
            cb_compile_status_list[compile_directive_depth] =
                CB_COMPILE_STATUS_FALSE;
          else
            cb_compile_status_list[compile_directive_depth] =
                CB_COMPILE_STATUS_TRUE;
          break;
        } else {
          switch (l->type) {
          case CB_CONSTANT_TYPE_ALPANUM:
            if (strlen(sbuff[3 + isNOT]) < 3 ||
                sbuff[3 + isNOT] != strchr(sbuff[3 + isNOT], '\"') ||
                sbuff[3 + isNOT] == strrchr(sbuff[3 + isNOT], '\"') ||
                strlen(strchr(sbuff[3 + isNOT] + 1, '\"')) > 1) {
              cb_compile_status = CB_COMPILE_STATUS_ERROR;
              cb_error(_("%s is not a string"), sbuff[3 + isNOT]);
              return;
            }
            strcpy(strchr(sbuff[3 + isNOT] + 1, '\"'), "");
            if (strcasecmp(sbuff[3 + isNOT] + 1, l->alphavalue) == 0) {
              if (isNOT)
                cb_compile_status_list[compile_directive_depth] =
                    CB_COMPILE_STATUS_FALSE;
              else
                cb_compile_status_list[compile_directive_depth] =
                    CB_COMPILE_STATUS_TRUE;
            }
            break;
          case CB_CONSTANT_TYPE_NUMERIC:
            // TODO
            break;
          default:
            break;
          }
          break;
        }
      }
      l = l->next;
    }
  } else if (strcasecmp(sbuff[0], "$ELSE") == 0) {
    if (compile_directive_depth >= MAX_DEPTH) {
      compile_directive_depth = -1;
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("Fatal error in $ELSE statement"));
      return;
    }
    if (compile_directive_depth < 0) {
      compile_directive_depth = -1;
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("$IF has no defined before the $ELSE"));
      return;
    }
    if (cb_compile_status_list[compile_directive_depth] ==
            CB_COMPILE_STATUS_TRUE_ELSE ||
        cb_compile_status_list[compile_directive_depth] ==
            CB_COMPILE_STATUS_FALSE_ELSE) {
      compile_directive_depth = -1;
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("$ELSE has continued"));
      return;
    }
    if (cb_compile_status_list[compile_directive_depth] ==
        CB_COMPILE_STATUS_FALSE)
      cb_compile_status_list[compile_directive_depth] =
          CB_COMPILE_STATUS_TRUE_ELSE;
    else
      cb_compile_status_list[compile_directive_depth] =
          CB_COMPILE_STATUS_FALSE_ELSE;
  } else if (strcasecmp(sbuff[0], "$END") == 0) {
    if (compile_directive_depth >= MAX_DEPTH) {
      compile_directive_depth = -1;
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("Fatal error in $END statement"));
      return;
    }
    if (compile_directive_depth < 0) {
      compile_directive_depth = -1;
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("$IF has no defined before the $END"));
      return;
    }
    cb_compile_status_list[compile_directive_depth] = CB_COMPILE_STATUS_NONE;
    compile_directive_depth--;
  } else if (strcasecmp(sbuff[0], "$SET") == 0) {
    if (strcasecmp(sbuff[1], "SOURCEFORMAT(FREE)") == 0) {
      cb_source_format = CB_FORMAT_FREE;
      return;
    } else if (strcasecmp(sbuff[1], "SOURCEFORMAT(FIXED)") == 0) {
      cb_source_format = CB_FORMAT_FIXED;
      return;
    } else if (strcasecmp(sbuff[1], "SOURCEFORMAT(FREE_1COL_ASTER)") == 0) {
      cb_source_format = CB_FORMAT_FREE_1COL_ASTER;
      cb_source_format1 = 1;
      return;
    } else if (strcasecmp(sbuff[1], "SOURCEFORMAT(VARIABLE)") == 0) {
      cb_source_format = CB_FORMAT_VARIABLE;
    } else {
      cb_compile_status = CB_COMPILE_STATUS_ERROR;
      cb_error(_("Invalid $SET"));
      return;
    }
  } else {
    cb_compile_status = CB_COMPILE_STATUS_ERROR;
    cb_error(_("Invalid $ statements"));
    return;
  }

  if (compile_directive_depth > -1) {
    for (i = 0; i <= compile_directive_depth; i++) {
      if (cb_compile_status_list[i] != CB_COMPILE_STATUS_TRUE &&
          cb_compile_status_list[i] != CB_COMPILE_STATUS_TRUE_ELSE) {
        cb_compile_status = CB_COMPILE_STATUS_FALSE;
        return;
      }
    }
  }
  if (*buff == '\n') {
    cb_compile_status = CB_COMPILE_STATUS_FALSE_END;
  } else {
    cb_compile_status = CB_COMPILE_STATUS_TRUE;
  }
}

/*
 * Read line
 */

static int ppinput(char *buff, int max_size) {

  char *bp;
  size_t gotcr;
  size_t continuation = 0;
  int ipchar;
  int i;
  int n;
  int coln;
  char *str1 = NULL;
  char *str2 = NULL;
  int comment_counter = 0;

start:
  /* read a line */
  gotcr = 0;
  ipchar = 0;
  for (n = 0; n < 256 && ipchar != '\n';) {
    ipchar = getc(ppin);
    if (ipchar == EOF) {
      if (n > 0) {
        break;
      }
      if (newline_count == 0) {
        return 0;
      }
      memset(buff, '\n', newline_count);
      buff[newline_count] = 0;
      newline_count = 0;
      return strlen(buff);
    }
    if (n == 0 && cb_source_format != CB_FORMAT_FIXED &&
        cb_source_format1 != 1 && cb_source_format != CB_FORMAT_VARIABLE) {
      if (ipchar != ' ' && ipchar != '\n') {
        buff[n++] = ' ';
      }
    }
    if (gotcr) {
      if (ipchar != '\n') {
        buff[n++] = '\r';
      }
      gotcr = 0;
    }
    if (ipchar == '\r') {
      gotcr = 1;
    } else if (ipchar == '\t') {
      buff[n++] = ' ';
      while (n % cb_tab_width != 0) {
        buff[n++] = ' ';
      }
    } else {
      buff[n++] = ipchar;
    }
  }

  if (buff[n - 1] != '\n') {
    cb_warning(_("Line not terminated by a newline"));
    buff[n++] = '\n';
  }
  buff[n] = 0;
  if (cb_source_format1 == 1 && buff[0] == '*' && buff[1] != '>') {
    strcpy(buff, "\n");
    return strlen(buff);
  }
  str1 = strstr(buff, "*>");
  if (str1 != NULL) {
    if ((str1 - buff) >= 7) {
      str2 = strstr(str1, "\"");
      if (str2 == NULL) {
        buff[str1 - buff] = '\n';
        buff[str1 - buff + 1] = '\0';
        n = strlen(buff);
      }
    }
  }
  check_directive(buff, &n);
  check_dollar_directive(buff, &n);
  if (cb_compile_status == CB_COMPILE_STATUS_ERROR) {
    return YY_NULL;
  }
  if (cb_compile_status == CB_COMPILE_STATUS_FALSE) {
    newline_count++;
    comment_counter++;
    goto start;
  }
  if (cb_compile_status == CB_COMPILE_STATUS_FALSE_END) {
    cb_compile_status = CB_COMPILE_STATUS_NONE;
    newline_count++;
    comment_counter++;
    goto start;
  }

  /* nothing more to do with free format */
  if (cb_source_format != CB_FORMAT_FIXED &&
      cb_source_format != CB_FORMAT_VARIABLE) {
    return n;
  }

  /* line too short */
  if (n < 8) {
    newline_count++;
    comment_counter++;
    goto start;
  }

  if (cb_flag_mfcomment) {
    if (buff[0] == '*' || buff[0] == '/') {
      /*if(!cb_flag_no_cobol_comment) {
              register_comment(0, buff, comment_counter++);
      }*/
      newline_count++;
      goto start;
    }
  }
  /* check the indicator (column 7) */
  bp = buff + 7;
  switch (buff[6]) {
  case ' ':
    break;
  case '-':
    continuation = 1;
    break;
  case 'd':
  case 'D':
    /* debugging line */
    if (cb_flag_debugging_line) {
      break;
    }
    newline_count++;
    comment_counter++;
    goto start;
  case '*':
  case '/':
    /* comment line */
    /*if(!cb_flag_no_cobol_comment) {
            register_comment(6, buff, comment_counter++);
    }*/
    newline_count++;
    goto start;
  default:
    /* invalid indicator */
    cb_error(_("Invalid indicator '%c' at column 7"), buff[6]);
    return YY_NULL;
  }

  /* skip comments that follow after AUTHORS, etc. */
  if (within_comment) {
    /* Check all of "Area A" */
    switch (n) {
    case 8:
      if (buff[7] == ' ') {
        newline_count++;
        comment_counter++;
        goto start;
      }
      break;
    case 9:
      if (!memcmp(&buff[7], "  ", 2)) {
        newline_count++;
        comment_counter++;
        goto start;
      }
      break;
    case 10:
      if (!memcmp(&buff[7], "   ", 3)) {
        newline_count++;
        comment_counter++;
        goto start;
      }
      break;
    default:
      if (!memcmp(&buff[7], "    ", 4)) {
        newline_count++;
        comment_counter++;
        goto start;
      }
      break;
    }
    within_comment = 0;
  }

  /* check the text that is longer than cb_text_column */
  if (n > cb_text_column + 1 && cb_source_format != CB_FORMAT_VARIABLE) {

    /* show warning if it is not whitespaces */
    if (cb_warn_column_overflow && last_line_2 < cb_source_line - 1) {
      for (coln = cb_text_column; coln < n; coln++) {
        if (buff[coln] != ' ' && buff[coln] != '\n') {
          cb_warning(_("Source text after column %d"), cb_text_column);
          break;
        }
      }
    }

    /* remove it */
    strcpy(buff + cb_text_column, "\n");
    last_line_2 = cb_source_line;
    n = cb_text_column + 1;
  }

  /* skip blank lines */
  for (i = 7; buff[i] == ' '; i++)
    ;
  if (buff[i] == '\n') {
    newline_count++;
    comment_counter++;
    goto start;
  }

  if (continuation) {
    /* line continuation */
    for (; *bp == ' '; bp++)
      ;

    /* validate concatenation */
    if (consecutive_quotation) {
      if (bp[0] == quotation_mark && bp[1] == quotation_mark) {
        bp++;
      } else {
        cb_error(_("Invalid line continuation"));
        return YY_NULL;
      }
      quotation_mark = 0;
      consecutive_quotation = 0;
    } else if (quotation_mark) {
      /* literal concatenation */
      if (*bp == quotation_mark) {
        bp++;
      } else {
        cb_error(_("Invalid line continuation"));
        return YY_NULL;
      }
    }
  } else {
    /* normal line */
    quotation_mark = 0;
    consecutive_quotation = 0;
  }

  /* check if string literal is to be continued */
  for (i = bp - buff; buff[i] != '\n'; i++) {
    if (buff[i] == '\'' || buff[i] == '\"') {
      if (quotation_mark == 0) {
        /* literal start */
        quotation_mark = buff[i];
      } else if (quotation_mark == buff[i]) {
        if (i == cb_text_column - 1) {
          /* consecutive quotation */
          consecutive_quotation = 1;
        } else {
          /* literal end */
          quotation_mark = 0;
        }
      }
    }
  }

  /* truncate trailing spaces, including the newline */
  if (quotation_mark) {
    for (; i < 72;) {
      buff[i++] = ' ';
    }
    buff[i] = 0;
  } else {
    for (i--; buff[i] == ' '; i--)
      ;
    if (buff[i] == '\'' || buff[i] == '\"') {
      buff[++i] = ' ';
    }
    buff[i + 1] = 0;
  }

  if (continuation) {
    memmove(buff, bp, strlen(bp) + 1);
    newline_count++;
    comment_counter++;
  } else {
    /* insert newlines at the start of the buffer */
    memmove(buff + newline_count, bp, strlen(bp) + 1);
    memset(buff, '\n', newline_count);
    newline_count = 1;
  }

  return strlen(buff);
}

static void ppecho_0(const char *text, struct cb_text_list **pqueue,
                     struct cb_replace_list **preplace,
                     void(ppecho_proc)(const char *)) {

  struct cb_replace_list *r;
  struct cb_text_list *l;
  struct cb_text_list *queue;

  if (suppress_echo) {
    /* generate no output */
  } else if (*pqueue == NULL && (text[0] == ' ' || text[0] == '\n')) {
    ppecho_proc(text);
  } else if (!*preplace) {
    for (; *pqueue; *pqueue = (*pqueue)->next) {
      ppecho_proc((*pqueue)->text);
    }
    ppecho_proc(text);
  } else {
    /* Do replacement */

    *pqueue = cb_text_list_add(*pqueue, text);

    while (*pqueue) {
      for (r = *preplace; r; r = r->next) {
        queue = *pqueue;
        for (l = r->old_text; l; l = l->next) {
          while (l && (l->text[0] == ' ' || l->text[0] == '\n')) {
            l = l->next;
          }
          if (l == NULL) {
            break;
          }
          while (queue && (queue->text[0] == ' ' || queue->text[0] == '\n')) {
            queue = queue->next;
          }
          if (queue == NULL) {
            return; /* partial match */
          }
          if (r->replace_type == CB_REPLACE_LEADING) {
            break;
          } else if (r->replace_type == CB_REPLACE_TRAILING) {
            break;
          } else if (r->replace_type == CB_REPLACE_OTHER) {
            if (strcasecmp(l->text, queue->text) != 0) {
              break;
            }
          }
          queue = queue->next;
        }
        if (r->replace_type == CB_REPLACE_LEADING) {
          if (!l || !queue) {
            continue;
          }
          if (strncasecmp(l->text, queue->text, strlen(l->text)) == 0) {
            break;
          }
        } else if (r->replace_type == CB_REPLACE_TRAILING) {
          if (!l || !queue || strlen(queue->text) < strlen(r->old_text->text)) {
            continue;
          }
          if (strcasecmp(queue->text + strlen(queue->text) -
                             strlen(r->old_text->text),
                         r->old_text->text) == 0) {
            break;
          }
        } else if (l == NULL) {
          /* match */
          break;
        }
      }

      /* match */
      if (r && r->replace_type == CB_REPLACE_LEADING) {
        int oldlen = strlen(l->text);
        for (l = *pqueue; l != queue; l = l->next) {
          ppecho_proc(l->text);
        }
        l = r->new_text;
        while (l && (l->text[0] == ' ' || l->text[0] == '\n')) {
          l = l->next;
        }
        if (l) {
          ppecho_proc(l->text);
        }
        ppecho_proc(queue->text + oldlen);
        queue = queue->next;
      } else if (r && r->replace_type == CB_REPLACE_TRAILING) {
        int i;
        int oldlen = strlen(l->text);
        for (l = *pqueue; l != queue; l = l->next) {
          ppecho_proc(l->text);
        }
        for (i = 0; i < strlen(queue->text) - oldlen; i++) {
          fputc(queue->text[i], ppout);
        }
        l = r->new_text;
        while (l && (l->text[0] == ' ' || l->text[0] == '\n')) {
          l = l->next;
        }
        if (l) {
          ppecho_proc(l->text);
        }
        queue = queue->next;
      } else if (r && l == NULL) {
        for (l = r->new_text; l; l = l->next) {
          ppecho_proc(l->text);
        }
      } else {
        /* no match */
        if (!*pqueue) {
          break;
        }
        ppecho_proc((*pqueue)->text);
        queue = (*pqueue)->next;
      }

      while (*pqueue != queue) {
        if (!*pqueue)
          break;

        l = (*pqueue)->next;
        free(*pqueue);
        *pqueue = l;
      }
    }
  }
}

static void ppecho_final(const char *text) { fputs(text, ppout); }

static void ppecho_2(const char *text) {
  /* process REPLACE */
  ppecho_0(text, &text_queue2, &current_replace_list, ppecho_final);
}

static void ppecho_1(const char *text) {
  /* process COPY REPLACING */
  ppecho_0(text, &text_queue1, &current_copy_replace_list, ppecho_2);
}

static void ppecho(const char *text) { ppecho_1(text); }

void pp_set_current_division(int divno) { current_division = divno; }

void pp_omit_data_entry_name(int on_off) { omit_data_entry_name = on_off; }

void pp_omit_data_redef_name(int on_off) { omit_data_redef_name = on_off; }

void register_comment(int comment_mark_index, char *buffer, int delta) {
  struct comment_info *p = malloc(sizeof(struct comment_info));
  p->file = cb_source_file;
  p->line = cb_source_line + delta + 1;

  // Remove the unnecessary part of the comment
  int str_len_original_line = strlen(buffer);
  int comment_end_index;
  if (buffer[str_len_original_line - 1] == '\n') {
    if (str_len_original_line >= 2 &&
        buffer[str_len_original_line - 1] == '\r') {
      comment_end_index = str_len_original_line - 2;
    } else {
      comment_end_index = str_len_original_line - 1;
    }
  } else {
    comment_end_index = str_len_original_line;
  }
  int comment_len = comment_end_index - comment_mark_index - 1;
  p->comment = malloc(comment_len + 1);
  memcpy(p->comment, buffer + comment_mark_index + 1, comment_len);
  p->comment[comment_len] = '\0';

  p->prev = comment_info_list_last;
  p->next = NULL;
  p->is_base_cobol_file = copy_stack->next == NULL;
  p->position_in_source_code = position_in_source_code;
  if (comment_info_list_last != NULL) {
    comment_info_list_last->next = p;
  }
  comment_info_list_last = p;
  if (comment_info_list_head == NULL) {
    comment_info_list_head = p;
  }
}
